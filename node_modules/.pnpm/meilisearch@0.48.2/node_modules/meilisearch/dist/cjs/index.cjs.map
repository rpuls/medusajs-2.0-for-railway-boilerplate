{"version":3,"file":"index.cjs","sources":["../../src/errors/meilisearch-error.ts","../../src/errors/meilisearch-api-error.ts","../../src/errors/meilisearch-request-error.ts","../../src/errors/meilisearch-timeout-error.ts","../../src/errors/version-hint-message.ts","../../src/package-version.ts","../../src/utils.ts","../../src/http-requests.ts","../../src/enqueued-task.ts","../../src/task.ts","../../src/batch.ts","../../src/types.ts","../../src/indexes.ts","../../src/meilisearch.ts","../../src/index.ts"],"sourcesContent":["export class MeiliSearchError extends Error {\n  override name = \"MeiliSearchError\";\n\n  constructor(...params: ConstructorParameters<typeof Error>) {\n    super(...params);\n  }\n}\n","import type { MeiliSearchErrorResponse } from \"../types.js\";\nimport { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchApiError extends MeiliSearchError {\n  override name = \"MeiliSearchApiError\";\n  override cause?: MeiliSearchErrorResponse;\n  readonly response: Response;\n\n  constructor(response: Response, responseBody?: MeiliSearchErrorResponse) {\n    super(\n      responseBody?.message ?? `${response.status}: ${response.statusText}`,\n    );\n\n    this.response = response;\n\n    if (responseBody !== undefined) {\n      this.cause = responseBody;\n    }\n  }\n}\n","import { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchRequestError extends MeiliSearchError {\n  override name = \"MeiliSearchRequestError\";\n\n  constructor(url: string, cause: unknown) {\n    super(`Request to ${url} has failed`, { cause });\n  }\n}\n","import { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchTimeOutError extends MeiliSearchError {\n  override name = \"MeiliSearchTimeOutError\";\n\n  constructor(message: string) {\n    super(message);\n  }\n}\n","export function versionErrorHintMessage(message: string, method: string) {\n  return `${message}\\nHint: It might not be working because maybe you're not up to date with the Meilisearch version that ${method} call requires.`;\n}\n","export const PACKAGE_VERSION = \"0.48.2\";\n","/** Removes undefined entries from object */\nfunction removeUndefinedFromObject(obj: Record<string, any>): object {\n  return Object.entries(obj).reduce(\n    (acc, curEntry) => {\n      const [key, val] = curEntry;\n      if (val !== undefined) acc[key] = val;\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n}\n\nasync function sleep(ms: number): Promise<void> {\n  return await new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction addProtocolIfNotPresent(host: string): string {\n  if (!(host.startsWith(\"https://\") || host.startsWith(\"http://\"))) {\n    return `http://${host}`;\n  }\n  return host;\n}\n\nfunction addTrailingSlash(url: string): string {\n  if (!url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\n\nexport {\n  sleep,\n  removeUndefinedFromObject,\n  addProtocolIfNotPresent,\n  addTrailingSlash,\n};\n","import type { Config, EnqueuedTaskObject } from \"./types.js\";\nimport { PACKAGE_VERSION } from \"./package-version.js\";\n\nimport {\n  MeiliSearchError,\n  MeiliSearchApiError,\n  MeiliSearchRequestError,\n} from \"./errors/index.js\";\n\nimport { addTrailingSlash, addProtocolIfNotPresent } from \"./utils.js\";\n\ntype queryParams<T> = { [key in keyof T]: string };\n\nfunction toQueryParams<T extends object>(parameters: T): queryParams<T> {\n  const params = Object.keys(parameters) as Array<keyof T>;\n\n  const queryParams = params.reduce<queryParams<T>>((acc, key) => {\n    const value = parameters[key];\n    if (value === undefined) {\n      return acc;\n    } else if (Array.isArray(value)) {\n      return { ...acc, [key]: value.join(\",\") };\n    } else if (value instanceof Date) {\n      return { ...acc, [key]: value.toISOString() };\n    }\n    return { ...acc, [key]: value };\n  }, {} as queryParams<T>);\n  return queryParams;\n}\n\nfunction constructHostURL(host: string): string {\n  try {\n    host = addProtocolIfNotPresent(host);\n    host = addTrailingSlash(host);\n    return host;\n  } catch {\n    throw new MeiliSearchError(\"The provided host is not valid.\");\n  }\n}\n\nfunction cloneAndParseHeaders(headers: HeadersInit): Record<string, string> {\n  if (Array.isArray(headers)) {\n    return headers.reduce(\n      (acc, headerPair) => {\n        acc[headerPair[0]] = headerPair[1];\n        return acc;\n      },\n      {} as Record<string, string>,\n    );\n  } else if (\"has\" in headers) {\n    const clonedHeaders: Record<string, string> = {};\n    (headers as Headers).forEach((value, key) => (clonedHeaders[key] = value));\n    return clonedHeaders;\n  } else {\n    return Object.assign({}, headers);\n  }\n}\n\nfunction createHeaders(config: Config): Record<string, any> {\n  const agentHeader = \"X-Meilisearch-Client\";\n  const packageAgent = `Meilisearch JavaScript (v${PACKAGE_VERSION})`;\n  const contentType = \"Content-Type\";\n  const authorization = \"Authorization\";\n  const headers = cloneAndParseHeaders(config.requestConfig?.headers ?? {});\n\n  // do not override if user provided the header\n  if (config.apiKey && !headers[authorization]) {\n    headers[authorization] = `Bearer ${config.apiKey}`;\n  }\n\n  if (!headers[contentType]) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n\n  // Creates the custom user agent with information on the package used.\n  if (config.clientAgents && Array.isArray(config.clientAgents)) {\n    const clients = config.clientAgents.concat(packageAgent);\n\n    headers[agentHeader] = clients.join(\" ; \");\n  } else if (config.clientAgents && !Array.isArray(config.clientAgents)) {\n    // If the header is defined but not an array\n    throw new MeiliSearchError(\n      `Meilisearch: The header \"${agentHeader}\" should be an array of string(s).\\n`,\n    );\n  } else {\n    headers[agentHeader] = packageAgent;\n  }\n\n  return headers;\n}\n\nclass HttpRequests {\n  headers: Record<string, any>;\n  url: URL;\n  requestConfig?: Config[\"requestConfig\"];\n  httpClient?: Required<Config>[\"httpClient\"];\n  requestTimeout?: number;\n\n  constructor(config: Config) {\n    this.headers = createHeaders(config);\n    this.requestConfig = config.requestConfig;\n    this.httpClient = config.httpClient;\n    this.requestTimeout = config.timeout;\n\n    try {\n      const host = constructHostURL(config.host);\n      this.url = new URL(host);\n    } catch {\n      throw new MeiliSearchError(\"The provided host is not valid.\");\n    }\n  }\n\n  async request({\n    method,\n    url,\n    params,\n    body,\n    config = {},\n  }: {\n    method: string;\n    url: string;\n    params?: { [key: string]: any };\n    body?: any;\n    config?: Record<string, any>;\n  }) {\n    const constructURL = new URL(url, this.url);\n    if (params) {\n      const queryParams = new URLSearchParams();\n      Object.keys(params)\n        .filter((x: string) => params[x] !== null)\n        .map((x: string) => queryParams.set(x, params[x]));\n      constructURL.search = queryParams.toString();\n    }\n\n    // in case a custom content-type is provided\n    // do not stringify body\n    if (!config.headers?.[\"Content-Type\"]) {\n      body = JSON.stringify(body);\n    }\n\n    const headers = { ...this.headers, ...config.headers };\n    const responsePromise = this.fetchWithTimeout(\n      constructURL.toString(),\n      {\n        ...config,\n        ...this.requestConfig,\n        method,\n        body,\n        headers,\n      },\n      this.requestTimeout,\n    );\n\n    const response = await responsePromise.catch((error: unknown) => {\n      throw new MeiliSearchRequestError(constructURL.toString(), error);\n    });\n\n    // When using a custom HTTP client, the response is returned to allow the user to parse/handle it as they see fit\n    if (this.httpClient !== undefined) {\n      return response;\n    }\n\n    const responseBody = await response.text();\n    const parsedResponse =\n      responseBody === \"\" ? undefined : JSON.parse(responseBody);\n\n    if (!response.ok) {\n      throw new MeiliSearchApiError(response, parsedResponse);\n    }\n\n    return parsedResponse;\n  }\n\n  async fetchWithTimeout(\n    url: string,\n    options: Record<string, any> | RequestInit | undefined,\n    timeout: HttpRequests[\"requestTimeout\"],\n  ): Promise<Response> {\n    return new Promise((resolve, reject) => {\n      const fetchFn = this.httpClient ? this.httpClient : fetch;\n\n      const fetchPromise = fetchFn(url, options);\n\n      const promises: Array<Promise<any>> = [fetchPromise];\n\n      // TimeoutPromise will not run if undefined or zero\n      let timeoutId: ReturnType<typeof setTimeout>;\n      if (timeout) {\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(() => {\n            reject(new Error(\"Error: Request Timed Out\"));\n          }, timeout);\n        });\n\n        promises.push(timeoutPromise);\n      }\n\n      Promise.race(promises)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          clearTimeout(timeoutId);\n        });\n    });\n  }\n\n  async get(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<void>;\n\n  async get<T = any>(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<T>;\n\n  async get(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"GET\",\n      url,\n      params,\n      config,\n    });\n  }\n\n  async post<T = any, R = EnqueuedTaskObject>(\n    url: string,\n    data?: T,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<R>;\n\n  async post(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"POST\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async put<T = any, R = EnqueuedTaskObject>(\n    url: string,\n    data?: T,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<R>;\n\n  async put(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"PUT\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async patch(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"PATCH\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async delete(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<EnqueuedTaskObject>;\n  async delete<T>(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<T>;\n  async delete(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"DELETE\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n}\n\nexport { HttpRequests, toQueryParams };\n","import type { EnqueuedTaskObject } from \"./types.js\";\n\nclass EnqueuedTask {\n  taskUid: EnqueuedTaskObject[\"taskUid\"];\n  indexUid: EnqueuedTaskObject[\"indexUid\"];\n  status: EnqueuedTaskObject[\"status\"];\n  type: EnqueuedTaskObject[\"type\"];\n  enqueuedAt: Date;\n\n  constructor(task: EnqueuedTaskObject) {\n    this.taskUid = task.taskUid;\n    this.indexUid = task.indexUid;\n    this.status = task.status;\n    this.type = task.type;\n    this.enqueuedAt = new Date(task.enqueuedAt);\n  }\n}\n\nexport { EnqueuedTask };\n","import { MeiliSearchTimeOutError } from \"./errors/index.js\";\nimport type {\n  Config,\n  WaitOptions,\n  TasksQuery,\n  TasksResults,\n  TaskObject,\n  CancelTasksQuery,\n  TasksResultsObject,\n  DeleteTasksQuery,\n} from \"./types.js\";\nimport { TaskStatus } from \"./types.js\";\nimport { HttpRequests, toQueryParams } from \"./http-requests.js\";\nimport { sleep } from \"./utils.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\n\nclass Task {\n  indexUid: TaskObject[\"indexUid\"];\n  status: TaskObject[\"status\"];\n  type: TaskObject[\"type\"];\n  uid: TaskObject[\"uid\"];\n  batchUid: TaskObject[\"batchUid\"];\n  canceledBy: TaskObject[\"canceledBy\"];\n  details: TaskObject[\"details\"];\n  error: TaskObject[\"error\"];\n  duration: TaskObject[\"duration\"];\n  startedAt: Date;\n  enqueuedAt: Date;\n  finishedAt: Date;\n\n  constructor(task: TaskObject) {\n    this.indexUid = task.indexUid;\n    this.status = task.status;\n    this.type = task.type;\n    this.uid = task.uid;\n    this.batchUid = task.batchUid;\n    this.details = task.details;\n    this.canceledBy = task.canceledBy;\n    this.error = task.error;\n    this.duration = task.duration;\n\n    this.startedAt = new Date(task.startedAt);\n    this.enqueuedAt = new Date(task.enqueuedAt);\n    this.finishedAt = new Date(task.finishedAt);\n  }\n}\n\nclass TaskClient {\n  httpRequest: HttpRequests;\n\n  constructor(config: Config) {\n    this.httpRequest = new HttpRequests(config);\n  }\n\n  /**\n   * Get one task\n   *\n   * @param uid - Unique identifier of the task\n   * @returns\n   */\n  async getTask(uid: number): Promise<Task> {\n    const url = `tasks/${uid}`;\n    const taskItem = await this.httpRequest.get<TaskObject>(url);\n    return new Task(taskItem);\n  }\n\n  /**\n   * Get tasks\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise containing all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    const url = `tasks`;\n\n    const tasks = await this.httpRequest.get<Promise<TasksResultsObject>>(\n      url,\n      toQueryParams<TasksQuery>(parameters),\n    );\n\n    return {\n      ...tasks,\n      results: tasks.results.map((task) => new Task(task)),\n    };\n  }\n\n  /**\n   * Wait for a task to be processed.\n   *\n   * @param taskUid - Task identifier\n   * @param options - Additional configuration options\n   * @returns Promise returning a task after it has been processed\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    const startingTime = Date.now();\n    while (Date.now() - startingTime < timeOutMs) {\n      const response = await this.getTask(taskUid);\n      if (\n        !(\n          [\n            TaskStatus.TASK_ENQUEUED,\n            TaskStatus.TASK_PROCESSING,\n          ] as readonly string[]\n        ).includes(response.status)\n      )\n        return response;\n      await sleep(intervalMs);\n    }\n    throw new MeiliSearchTimeOutError(\n      `timeout of ${timeOutMs}ms has exceeded on process ${taskUid} when waiting a task to be resolved.`,\n    );\n  }\n\n  /**\n   * Waits for multiple tasks to be processed\n   *\n   * @param taskUids - Tasks identifier list\n   * @param options - Wait options\n   * @returns Promise returning a list of tasks after they have been processed\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    const tasks: Task[] = [];\n    for (const taskUid of taskUids) {\n      const task = await this.waitForTask(taskUid, {\n        timeOutMs,\n        intervalMs,\n      });\n      tasks.push(task);\n    }\n    return tasks;\n  }\n\n  /**\n   * Cancel a list of enqueued or processing tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async cancelTasks(parameters: CancelTasksQuery = {}): Promise<EnqueuedTask> {\n    const url = `tasks/cancel`;\n\n    const task = await this.httpRequest.post(\n      url,\n      {},\n      toQueryParams<CancelTasksQuery>(parameters),\n    );\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Delete a list tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteTasks(parameters: DeleteTasksQuery = {}): Promise<EnqueuedTask> {\n    const url = `tasks`;\n\n    const task = await this.httpRequest.delete(\n      url,\n      {},\n      toQueryParams<DeleteTasksQuery>(parameters),\n    );\n    return new EnqueuedTask(task);\n  }\n}\n\nexport { TaskClient, Task };\n","import type {\n  Config,\n  BatchObject,\n  BatchesQuery,\n  BatchesResults,\n  BatchesResultsObject,\n} from \"./types.js\";\nimport { HttpRequests, toQueryParams } from \"./http-requests.js\";\n\nclass Batch {\n  uid: BatchObject[\"uid\"];\n  details: BatchObject[\"details\"];\n  stats: BatchObject[\"stats\"];\n  startedAt: BatchObject[\"startedAt\"];\n  finishedAt: BatchObject[\"finishedAt\"];\n  duration: BatchObject[\"duration\"];\n  progress: BatchObject[\"progress\"];\n\n  constructor(batch: BatchObject) {\n    this.uid = batch.uid;\n    this.details = batch.details;\n    this.stats = batch.stats;\n    this.startedAt = batch.startedAt;\n    this.finishedAt = batch.finishedAt;\n    this.duration = batch.duration;\n    this.progress = batch.progress;\n  }\n}\n\nclass BatchClient {\n  httpRequest: HttpRequests;\n\n  constructor(config: Config) {\n    this.httpRequest = new HttpRequests(config);\n  }\n\n  /**\n   * Get one batch\n   *\n   * @param uid - Unique identifier of the batch\n   * @returns\n   */\n  async getBatch(uid: number): Promise<Batch> {\n    const url = `batches/${uid}`;\n    const batch = await this.httpRequest.get<BatchObject>(url);\n    return new Batch(batch);\n  }\n\n  /**\n   * Get batches\n   *\n   * @param parameters - Parameters to browse the batches\n   * @returns Promise containing all batches\n   */\n  async getBatches(parameters: BatchesQuery = {}): Promise<BatchesResults> {\n    const url = `batches`;\n\n    const batches = await this.httpRequest.get<Promise<BatchesResultsObject>>(\n      url,\n      toQueryParams<BatchesQuery>(parameters),\n    );\n\n    return {\n      ...batches,\n      results: batches.results.map((batch) => new Batch(batch)),\n    };\n  }\n}\n\nexport { BatchClient, Batch };\n","// Type definitions for meilisearch\n// Project: https://github.com/meilisearch/meilisearch-js\n// Definitions by: qdequele <quentin@meilisearch.com> <https://github.com/meilisearch>\n// Definitions: https://github.com/meilisearch/meilisearch-js\n// TypeScript Version: ^3.8.3\n\nimport { Task } from \"./task.js\";\nimport { Batch } from \"./batch.js\";\n\nexport type Config = {\n  host: string;\n  apiKey?: string;\n  clientAgents?: string[];\n  requestConfig?: Partial<Omit<RequestInit, \"body\" | \"method\">>;\n  httpClient?: (input: string, init?: RequestInit) => Promise<any>;\n  timeout?: number;\n};\n\n///\n/// Resources\n///\n\nexport type Pagination = {\n  offset?: number;\n  limit?: number;\n};\n\nexport type ResourceQuery = Pagination & {};\n\nexport type ResourceResults<T> = Pagination & {\n  results: T;\n  total: number;\n};\n\n///\n/// Indexes\n///\n\nexport type IndexOptions = {\n  primaryKey?: string;\n};\n\nexport type IndexObject = {\n  uid: string;\n  primaryKey?: string;\n  createdAt: Date;\n  updatedAt: Date;\n};\n\nexport type IndexesQuery = ResourceQuery & {};\n\nexport type IndexesResults<T> = ResourceResults<T> & {};\n\n/*\n * SEARCH PARAMETERS\n */\n\nexport const MatchingStrategies = {\n  ALL: \"all\",\n  LAST: \"last\",\n  FREQUENCY: \"frequency\",\n} as const;\n\nexport type MatchingStrategies =\n  (typeof MatchingStrategies)[keyof typeof MatchingStrategies];\n\nexport type Filter = string | Array<string | string[]>;\n\nexport type Query = {\n  q?: string | null;\n};\n\nexport type Highlight = {\n  attributesToHighlight?: string[];\n  highlightPreTag?: string;\n  highlightPostTag?: string;\n};\n\nexport type Crop = {\n  attributesToCrop?: string[];\n  cropLength?: number;\n  cropMarker?: string;\n};\n\n// `facetName` becomes mandatory when using `searchForFacetValues`\nexport type SearchForFacetValuesParams = Omit<SearchParams, \"facetName\"> & {\n  facetName: string;\n};\n\nexport type FacetHit = {\n  value: string;\n  count: number;\n};\n\nexport type SearchForFacetValuesResponse = {\n  facetHits: FacetHit[];\n  facetQuery: string | null;\n  processingTimeMs: number;\n};\n\nexport type HybridSearch = {\n  embedder: string;\n  semanticRatio?: number;\n};\n\n// https://www.meilisearch.com/docs/reference/api/settings#localized-attributes\nexport type Locale = string;\n\nexport type SearchParams = Query &\n  Pagination &\n  Highlight &\n  Crop & {\n    filter?: Filter;\n    sort?: string[];\n    facets?: string[];\n    attributesToRetrieve?: string[];\n    showMatchesPosition?: boolean;\n    matchingStrategy?: MatchingStrategies;\n    hitsPerPage?: number;\n    page?: number;\n    facetName?: string;\n    facetQuery?: string;\n    vector?: number[] | null;\n    showRankingScore?: boolean;\n    showRankingScoreDetails?: boolean;\n    rankingScoreThreshold?: number;\n    attributesToSearchOn?: string[] | null;\n    hybrid?: HybridSearch;\n    distinct?: string;\n    retrieveVectors?: boolean;\n    locales?: Locale[];\n  };\n\n// Search parameters for searches made with the GET method\n// Are different than the parameters for the POST method\nexport type SearchRequestGET = Pagination &\n  Query &\n  Omit<Highlight, \"attributesToHighlight\"> &\n  Omit<Crop, \"attributesToCrop\"> & {\n    filter?: string;\n    sort?: string;\n    facets?: string;\n    attributesToRetrieve?: string;\n    attributesToHighlight?: string;\n    attributesToCrop?: string;\n    showMatchesPosition?: boolean;\n    vector?: string | null;\n    attributesToSearchOn?: string | null;\n    hybridEmbedder?: string;\n    hybridSemanticRatio?: number;\n    rankingScoreThreshold?: number;\n    distinct?: string;\n    retrieveVectors?: boolean;\n    locales?: Locale[];\n  };\n\nexport type MergeFacets = {\n  maxValuesPerFacet?: number | null;\n};\n\nexport type FederationOptions = { weight: number };\nexport type MultiSearchFederation = {\n  limit?: number;\n  offset?: number;\n  facetsByIndex?: Record<string, string[]>;\n  mergeFacets?: MergeFacets | null;\n};\n\nexport type MultiSearchQuery = SearchParams & { indexUid: string };\nexport type MultiSearchQueryWithFederation = MultiSearchQuery & {\n  federationOptions?: FederationOptions;\n};\n\nexport type MultiSearchParams = {\n  queries: MultiSearchQuery[];\n};\nexport type FederatedMultiSearchParams = {\n  federation: MultiSearchFederation;\n  queries: MultiSearchQueryWithFederation[];\n};\n\nexport type CategoriesDistribution = {\n  [category: string]: number;\n};\n\nexport type Facet = string;\nexport type FacetDistribution = Record<Facet, CategoriesDistribution>;\nexport type MatchesPosition<T> = Partial<\n  Record<keyof T, Array<{ start: number; length: number; indices?: number[] }>>\n>;\n\nexport type RankingScoreDetails = {\n  words?: {\n    order: number;\n    matchingWords: number;\n    maxMatchingWords: number;\n    score: number;\n  };\n  typo?: {\n    order: number;\n    typoCount: number;\n    maxTypoCount: number;\n    score: number;\n  };\n  proximity?: {\n    order: number;\n    score: number;\n  };\n  attribute?: {\n    order: number;\n    attributes_ranking_order: number;\n    attributes_query_word_order: number;\n    score: number;\n  };\n  exactness?: {\n    order: number;\n    matchType: string;\n    score: number;\n  };\n  [key: string]: Record<string, any> | undefined;\n};\n\nexport type FederationDetails = {\n  indexUid: string;\n  queriesPosition: number;\n  weightedRankingScore: number;\n};\n\nexport type Hit<T = Record<string, any>> = T & {\n  _formatted?: Partial<T>;\n  _matchesPosition?: MatchesPosition<T>;\n  _rankingScore?: number;\n  _rankingScoreDetails?: RankingScoreDetails;\n  _federation?: FederationDetails;\n};\n\nexport type Hits<T = Record<string, any>> = Array<Hit<T>>;\n\nexport type FacetStat = { min: number; max: number };\nexport type FacetStats = Record<string, FacetStat>;\n\nexport type FacetsByIndex = Record<\n  string,\n  {\n    distribution: FacetDistribution;\n    stats: FacetStats;\n  }\n>;\n\nexport type SearchResponse<\n  T = Record<string, any>,\n  S extends SearchParams | undefined = undefined,\n> = {\n  hits: Hits<T>;\n  processingTimeMs: number;\n  query: string;\n  facetDistribution?: FacetDistribution;\n  facetStats?: FacetStats;\n  facetsByIndex?: FacetsByIndex;\n} & (undefined extends S\n  ? Partial<FinitePagination & InfinitePagination>\n  : true extends IsFinitePagination<NonNullable<S>>\n    ? FinitePagination\n    : InfinitePagination);\n\ntype FinitePagination = {\n  totalHits: number;\n  hitsPerPage: number;\n  page: number;\n  totalPages: number;\n};\ntype InfinitePagination = {\n  offset: number;\n  limit: number;\n  estimatedTotalHits: number;\n};\n\ntype IsFinitePagination<S extends SearchParams> = Or<\n  HasHitsPerPage<S>,\n  HasPage<S>\n>;\n\ntype Or<A extends boolean, B extends boolean> = true extends A\n  ? true\n  : true extends B\n    ? true\n    : false;\n\ntype HasHitsPerPage<S extends SearchParams> = undefined extends S[\"hitsPerPage\"]\n  ? false\n  : true;\n\ntype HasPage<S extends SearchParams> = undefined extends S[\"page\"]\n  ? false\n  : true;\n\nexport type MultiSearchResult<T> = SearchResponse<T> & { indexUid: string };\n\nexport type MultiSearchResponse<T = Record<string, any>> = {\n  results: Array<MultiSearchResult<T>>;\n};\n\nexport type MultiSearchResponseOrSearchResponse<\n  T1 extends FederatedMultiSearchParams | MultiSearchParams,\n  T2 extends Record<string, unknown> = Record<string, any>,\n> = T1 extends FederatedMultiSearchParams\n  ? SearchResponse<T2>\n  : MultiSearchResponse<T2>;\n\nexport type FieldDistribution = {\n  [field: string]: number;\n};\n\nexport type SearchSimilarDocumentsParams = {\n  id: string | number;\n  offset?: number;\n  limit?: number;\n  filter?: Filter;\n  embedder?: string;\n  attributesToRetrieve?: string[];\n  showRankingScore?: boolean;\n  showRankingScoreDetails?: boolean;\n  rankingScoreThreshold?: number;\n};\n\n/*\n ** Documents\n */\n\ntype Fields<T = Record<string, any>> =\n  | Array<Extract<keyof T, string>>\n  | Extract<keyof T, string>;\n\nexport type DocumentOptions = {\n  primaryKey?: string;\n};\n\nexport const ContentTypeEnum: Readonly<Record<string, ContentType>> = {\n  JSON: \"application/json\",\n  CSV: \"text/csv\",\n  NDJSON: \"application/x-ndjson\",\n};\n\nexport type ContentType =\n  | \"text/csv\"\n  | \"application/x-ndjson\"\n  | \"application/json\";\n\nexport type RawDocumentAdditionOptions = DocumentOptions & {\n  csvDelimiter?: string;\n};\n\nexport type DocumentsQuery<T = Record<string, any>> = ResourceQuery & {\n  fields?: Fields<T>;\n  filter?: Filter;\n  limit?: number;\n  offset?: number;\n  retrieveVectors?: boolean;\n};\n\nexport type DocumentQuery<T = Record<string, any>> = {\n  fields?: Fields<T>;\n};\n\nexport type DocumentsDeletionQuery = {\n  filter: Filter;\n};\n\nexport type DocumentsIds = string[] | number[];\n\nexport type UpdateDocumentsByFunctionOptions = {\n  function: string;\n  filter?: string | string[];\n  context?: Record<string, any>;\n};\n\n/*\n ** Settings\n */\n\nexport type FilterableAttributes = string[] | null;\nexport type DistinctAttribute = string | null;\nexport type SearchableAttributes = string[] | null;\nexport type SortableAttributes = string[] | null;\nexport type DisplayedAttributes = string[] | null;\nexport type RankingRules = string[] | null;\nexport type StopWords = string[] | null;\nexport type Synonyms = {\n  [field: string]: string[];\n} | null;\nexport type TypoTolerance = {\n  enabled?: boolean | null;\n  disableOnAttributes?: string[] | null;\n  disableOnWords?: string[] | null;\n  minWordSizeForTypos?: {\n    oneTypo?: number | null;\n    twoTypos?: number | null;\n  };\n} | null;\nexport type SeparatorTokens = string[] | null;\nexport type NonSeparatorTokens = string[] | null;\nexport type Dictionary = string[] | null;\nexport type ProximityPrecision = \"byWord\" | \"byAttribute\";\n\nexport type Distribution = {\n  mean: number;\n  sigma: number;\n};\n\nexport type OpenAiEmbedder = {\n  source: \"openAi\";\n  model?: string;\n  apiKey?: string;\n  documentTemplate?: string;\n  dimensions?: number;\n  distribution?: Distribution;\n  url?: string;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type HuggingFaceEmbedder = {\n  source: \"huggingFace\";\n  model?: string;\n  revision?: string;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type UserProvidedEmbedder = {\n  source: \"userProvided\";\n  dimensions: number;\n  distribution?: Distribution;\n  binaryQuantized?: boolean;\n};\n\nexport type RestEmbedder = {\n  source: \"rest\";\n  url: string;\n  apiKey?: string;\n  dimensions?: number;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  request: Record<string, any>;\n  response: Record<string, any>;\n  headers?: Record<string, string>;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type OllamaEmbedder = {\n  source: \"ollama\";\n  url?: string;\n  apiKey?: string;\n  model?: string;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  dimensions?: number;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type Embedder =\n  | OpenAiEmbedder\n  | HuggingFaceEmbedder\n  | UserProvidedEmbedder\n  | RestEmbedder\n  | OllamaEmbedder\n  | null;\n\nexport type Embedders = Record<string, Embedder> | null;\n\nexport type FacetOrder = \"alpha\" | \"count\";\n\nexport type Faceting = {\n  maxValuesPerFacet?: number | null;\n  sortFacetValuesBy?: Record<string, FacetOrder> | null;\n};\n\nexport type PaginationSettings = {\n  maxTotalHits?: number | null;\n};\n\nexport type SearchCutoffMs = number | null;\n\nexport type LocalizedAttribute = {\n  attributePatterns: string[];\n  locales: Locale[];\n};\n\nexport type LocalizedAttributes = LocalizedAttribute[] | null;\n\nexport type PrefixSearch = \"indexingTime\" | \"disabled\";\n\nexport type Settings = {\n  filterableAttributes?: FilterableAttributes;\n  distinctAttribute?: DistinctAttribute;\n  sortableAttributes?: SortableAttributes;\n  searchableAttributes?: SearchableAttributes;\n  displayedAttributes?: DisplayedAttributes;\n  rankingRules?: RankingRules;\n  stopWords?: StopWords;\n  synonyms?: Synonyms;\n  typoTolerance?: TypoTolerance;\n  faceting?: Faceting;\n  pagination?: PaginationSettings;\n  separatorTokens?: SeparatorTokens;\n  nonSeparatorTokens?: NonSeparatorTokens;\n  dictionary?: Dictionary;\n  proximityPrecision?: ProximityPrecision;\n  embedders?: Embedders;\n  searchCutoffMs?: SearchCutoffMs;\n  localizedAttributes?: LocalizedAttributes;\n\n  /**\n   * Enable facet searching on all the filters of an index (requires Meilisearch\n   * 1.12.0 or later)\n   */\n  facetSearch?: boolean;\n  /**\n   * Enable the ability to search a word by prefix on an index (requires\n   * Meilisearch 1.12.0 or later)\n   */\n  prefixSearch?: \"indexingTime\" | \"disabled\";\n};\n\n/*\n ** TASKS\n */\n\nexport const TaskStatus = {\n  TASK_SUCCEEDED: \"succeeded\",\n  TASK_PROCESSING: \"processing\",\n  TASK_FAILED: \"failed\",\n  TASK_ENQUEUED: \"enqueued\",\n  TASK_CANCELED: \"canceled\",\n} as const;\n\nexport type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];\n\nexport const TaskTypes = {\n  DOCUMENTS_ADDITION_OR_UPDATE: \"documentAdditionOrUpdate\",\n  DOCUMENT_DELETION: \"documentDeletion\",\n  DUMP_CREATION: \"dumpCreation\",\n  INDEX_CREATION: \"indexCreation\",\n  INDEX_DELETION: \"indexDeletion\",\n  INDEXES_SWAP: \"indexSwap\",\n  INDEX_UPDATE: \"indexUpdate\",\n  SETTINGS_UPDATE: \"settingsUpdate\",\n  SNAPSHOT_CREATION: \"snapshotCreation\",\n  TASK_CANCELATION: \"taskCancelation\",\n  TASK_DELETION: \"taskDeletion\",\n} as const;\n\nexport type TaskTypes = (typeof TaskTypes)[keyof typeof TaskTypes];\n\nexport type TasksQuery = {\n  indexUids?: string[];\n  uids?: number[];\n  types?: TaskTypes[];\n  statuses?: TaskStatus[];\n  canceledBy?: number[];\n  beforeEnqueuedAt?: Date;\n  afterEnqueuedAt?: Date;\n  beforeStartedAt?: Date;\n  afterStartedAt?: Date;\n  beforeFinishedAt?: Date;\n  afterFinishedAt?: Date;\n  limit?: number;\n  from?: number;\n  /**\n   * If true, the tasks are returned in reverse order (requires Meilisearch\n   * 1.12.0 or later)\n   */\n  reverse?: boolean;\n};\n\nexport type CancelTasksQuery = Omit<TasksQuery, \"limit\" | \"from\"> & {};\n\nexport type DeleteTasksQuery = Omit<TasksQuery, \"limit\" | \"from\"> & {};\n\nexport type EnqueuedTaskObject = {\n  taskUid: number;\n  indexUid?: string;\n  status: TaskStatus;\n  type: TaskTypes;\n  enqueuedAt: string;\n  canceledBy: number;\n};\n\nexport type TaskObject = Omit<EnqueuedTaskObject, \"taskUid\"> & {\n  uid: number;\n  /** The UID of the batch that the task belongs to (`null` for enqueued tasks) */\n  batchUid: number | null;\n  details: {\n    // Number of documents sent\n    receivedDocuments?: number;\n\n    // Number of documents successfully indexed/updated in Meilisearch\n    indexedDocuments?: number;\n\n    // Number of deleted documents\n    deletedDocuments?: number;\n\n    // Number of documents found on a batch-delete\n    providedIds?: number;\n\n    // Primary key on index creation\n    primaryKey?: string;\n\n    // Ranking rules on settings actions\n    rankingRules?: RankingRules;\n\n    // Searchable attributes on settings actions\n    searchableAttributes?: SearchableAttributes;\n\n    // Displayed attributes on settings actions\n    displayedAttributes?: DisplayedAttributes;\n\n    // Filterable attributes on settings actions\n    filterableAttributes?: FilterableAttributes;\n\n    // Sortable attributes on settings actions\n    sortableAttributes?: SortableAttributes;\n\n    // Stop words on settings actions\n    stopWords?: StopWords;\n\n    // Stop words on settings actions\n    synonyms?: Synonyms;\n\n    // Distinct attribute on settings actions\n    distinctAttribute?: DistinctAttribute;\n\n    // Object containing the payload originating the `indexSwap` task creation\n    swaps?: SwapIndexesParams;\n\n    // Number of tasks that matched the originalQuery filter\n    matchedTasks?: number;\n\n    // Number of tasks that were canceled\n    canceledTasks?: number;\n\n    // Number of tasks that were deleted\n    deletedTasks?: number;\n\n    // Query parameters used to filter the tasks\n    originalFilter?: string;\n  };\n  error: MeiliSearchErrorResponse | null;\n  duration: string;\n  startedAt: string;\n  finishedAt: string;\n};\n\nexport type SwapIndexesParams = Array<{\n  indexes: string[];\n}>;\n\ntype CursorResults<T> = {\n  results: T[];\n  limit: number;\n  from: number;\n  next: number;\n  total: number;\n};\n\nexport type TasksResults = CursorResults<Task>;\nexport type TasksResultsObject = CursorResults<TaskObject>;\n\nexport type WaitOptions = {\n  timeOutMs?: number;\n  intervalMs?: number;\n};\n\n/*\n ** BATCHES\n */\n\n/**\n * Represents a batch operation object containing information about tasks\n * processing\n */\nexport type BatchObject = {\n  /** Unique identifier for the batch */\n  uid: number;\n\n  /** Details about document processing */\n  details: {\n    /** Number of documents received in the batch */\n    receivedDocuments?: number;\n    /** Number of documents successfully indexed */\n    indexedDocuments?: number;\n    /** Number of documents deleted in the batch */\n    deletedDocuments?: number;\n  };\n\n  /** Progress and indexing step of the batch, null if the batch is finished */\n  progress: null | {\n    /** An array of all the steps currently being processed */\n    steps: Array<{\n      /**\n       * A string representing the name of the current step NOT stable. Only use\n       * for debugging purposes.\n       */\n      currentStep: string;\n      /** Number of finished tasks */\n      finished: number;\n      /** Total number of tasks to finish before moving to the next step */\n      total: number;\n    }>;\n    /** Percentage of progression of all steps currently being processed */\n    percentage: number;\n  };\n\n  /** Statistics about tasks within the batch */\n  stats: {\n    /** Total number of tasks in the batch */\n    totalNbTasks: number;\n    /** Count of tasks in each status */\n    status: {\n      /** Number of successfully completed tasks */\n      succeeded: number;\n      /** Number of failed tasks */\n      failed: number;\n      /** Number of canceled tasks */\n      canceled: number;\n      /** Number of tasks currently processing */\n      processing: number;\n      /** Number of tasks waiting to be processed */\n      enqueued: number;\n    };\n    /** Count of tasks by type */\n    types: Record<TaskTypes, number>;\n    /** Count of tasks by index UID */\n    indexUids: Record<string, number>;\n  };\n\n  /** Timestamp when the batch started processing (rfc3339 format) */\n  startedAt: string;\n  /** Timestamp when the batch finished processing (rfc3339 format) */\n  finishedAt: string;\n  /** Duration of batch processing */\n  duration: string;\n};\n\nexport type BatchesQuery = {\n  /** The batch should contain the specified task UIDs */\n  uids?: number[];\n  batchUids?: number[];\n  types?: TaskTypes[];\n  statuses?: TaskStatus[];\n  indexUids?: string[];\n  canceledBy?: number[];\n  beforeEnqueuedAt?: Date;\n  afterEnqueuedAt?: Date;\n  beforeStartedAt?: Date;\n  afterStartedAt?: Date;\n  beforeFinishedAt?: Date;\n  afterFinishedAt?: Date;\n  limit?: number;\n  from?: number;\n};\n\nexport type BatchesResults = CursorResults<Batch>;\nexport type BatchesResultsObject = CursorResults<BatchObject>;\n\n/*\n *** HEALTH\n */\n\nexport type Health = {\n  status: \"available\";\n};\n\n/*\n *** STATS\n */\n\nexport type IndexStats = {\n  numberOfDocuments: number;\n  isIndexing: boolean;\n  fieldDistribution: FieldDistribution;\n};\n\nexport type Stats = {\n  databaseSize: number;\n  lastUpdate: string;\n  indexes: {\n    [index: string]: IndexStats;\n  };\n};\n\n/*\n ** Keys\n */\n\nexport type Key = {\n  uid: string;\n  description: string;\n  name: string | null;\n  key: string;\n  actions: string[];\n  indexes: string[];\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n};\n\nexport type KeyCreation = {\n  uid?: string;\n  name?: string;\n  description?: string;\n  actions: string[];\n  indexes: string[];\n  expiresAt: Date | null;\n};\n\nexport type KeyUpdate = {\n  name?: string;\n  description?: string;\n};\n\nexport type KeysQuery = ResourceQuery & {};\n\nexport type KeysResults = ResourceResults<Key[]> & {};\n\n/*\n ** version\n */\nexport type Version = {\n  commitSha: string;\n  commitDate: string;\n  pkgVersion: string;\n};\n\n/*\n ** ERROR HANDLER\n */\n\nexport interface FetchError extends Error {\n  type: string;\n  errno: string;\n  code: string;\n}\n\nexport type MeiliSearchErrorResponse = {\n  message: string;\n  // https://www.meilisearch.com/docs/reference/errors/error_codes\n  code: string;\n  // https://www.meilisearch.com/docs/reference/errors/overview#errors\n  type: string;\n  link: string;\n};\n\n// @TODO: This doesn't seem to be up to date, and its usefullness comes into question.\nexport const ErrorStatusCode = {\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_creation_failed */\n  INDEX_CREATION_FAILED: \"index_creation_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_index_uid */\n  MISSING_INDEX_UID: \"missing_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_already_exists */\n  INDEX_ALREADY_EXISTS: \"index_already_exists\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_found */\n  INDEX_NOT_FOUND: \"index_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_uid */\n  INVALID_INDEX_UID: \"invalid_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_accessible */\n  INDEX_NOT_ACCESSIBLE: \"index_not_accessible\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_offset */\n  INVALID_INDEX_OFFSET: \"invalid_index_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_limit */\n  INVALID_INDEX_LIMIT: \"invalid_index_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_state */\n  INVALID_STATE: \"invalid_state\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#primary_key_inference_failed */\n  PRIMARY_KEY_INFERENCE_FAILED: \"primary_key_inference_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_primary_key_already_exists */\n  INDEX_PRIMARY_KEY_ALREADY_EXISTS: \"index_primary_key_already_exists\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_primary_key */\n  INVALID_INDEX_PRIMARY_KEY: \"invalid_index_primary_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#max_fields_limit_exceeded */\n  DOCUMENTS_FIELDS_LIMIT_REACHED: \"document_fields_limit_reached\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */\n  MISSING_DOCUMENT_ID: \"missing_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */\n  INVALID_DOCUMENT_ID: \"invalid_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_content_type */\n  INVALID_CONTENT_TYPE: \"invalid_content_type\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_content_type */\n  MISSING_CONTENT_TYPE: \"missing_content_type\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_fields */\n  INVALID_DOCUMENT_FIELDS: \"invalid_document_fields\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_limit */\n  INVALID_DOCUMENT_LIMIT: \"invalid_document_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_offset */\n  INVALID_DOCUMENT_OFFSET: \"invalid_document_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_filter */\n  INVALID_DOCUMENT_FILTER: \"invalid_document_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_filter */\n  MISSING_DOCUMENT_FILTER: \"missing_document_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_vectors_field */\n  INVALID_DOCUMENT_VECTORS_FIELD: \"invalid_document_vectors_field\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#payload_too_large */\n  PAYLOAD_TOO_LARGE: \"payload_too_large\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_payload */\n  MISSING_PAYLOAD: \"missing_payload\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#malformed_payload */\n  MALFORMED_PAYLOAD: \"malformed_payload\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#no_space_left_on_device */\n  NO_SPACE_LEFT_ON_DEVICE: \"no_space_left_on_device\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_store_file */\n  INVALID_STORE_FILE: \"invalid_store_file\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_ranking_rules */\n  INVALID_RANKING_RULES: \"missing_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_request */\n  INVALID_REQUEST: \"invalid_request\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_geo_field */\n  INVALID_DOCUMENT_GEO_FIELD: \"invalid_document_geo_field\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_q */\n  INVALID_SEARCH_Q: \"invalid_search_q\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_offset */\n  INVALID_SEARCH_OFFSET: \"invalid_search_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_limit */\n  INVALID_SEARCH_LIMIT: \"invalid_search_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_page */\n  INVALID_SEARCH_PAGE: \"invalid_search_page\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_hits_per_page */\n  INVALID_SEARCH_HITS_PER_PAGE: \"invalid_search_hits_per_page\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_retrieve */\n  INVALID_SEARCH_ATTRIBUTES_TO_RETRIEVE:\n    \"invalid_search_attributes_to_retrieve\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_crop */\n  INVALID_SEARCH_ATTRIBUTES_TO_CROP: \"invalid_search_attributes_to_crop\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_length */\n  INVALID_SEARCH_CROP_LENGTH: \"invalid_search_crop_length\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_highlight */\n  INVALID_SEARCH_ATTRIBUTES_TO_HIGHLIGHT:\n    \"invalid_search_attributes_to_highlight\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_show_matches_position */\n  INVALID_SEARCH_SHOW_MATCHES_POSITION: \"invalid_search_show_matches_position\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_filter */\n  INVALID_SEARCH_FILTER: \"invalid_search_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_sort */\n  INVALID_SEARCH_SORT: \"invalid_search_sort\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_facets */\n  INVALID_SEARCH_FACETS: \"invalid_search_facets\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_pre_tag */\n  INVALID_SEARCH_HIGHLIGHT_PRE_TAG: \"invalid_search_highlight_pre_tag\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_post_tag */\n  INVALID_SEARCH_HIGHLIGHT_POST_TAG: \"invalid_search_highlight_post_tag\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_marker */\n  INVALID_SEARCH_CROP_MARKER: \"invalid_search_crop_marker\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_matching_strategy */\n  INVALID_SEARCH_MATCHING_STRATEGY: \"invalid_search_matching_strategy\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_vector */\n  INVALID_SEARCH_VECTOR: \"invalid_search_vector\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_search_on */\n  INVALID_SEARCH_ATTRIBUTES_TO_SEARCH_ON:\n    \"invalid_search_attributes_to_search_on\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#bad_request */\n  BAD_REQUEST: \"bad_request\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#document_not_found */\n  DOCUMENT_NOT_FOUND: \"document_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#internal */\n  INTERNAL: \"internal\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key */\n  INVALID_API_KEY: \"invalid_api_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_description */\n  INVALID_API_KEY_DESCRIPTION: \"invalid_api_key_description\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_actions */\n  INVALID_API_KEY_ACTIONS: \"invalid_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_indexes */\n  INVALID_API_KEY_INDEXES: \"invalid_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_expires_at */\n  INVALID_API_KEY_EXPIRES_AT: \"invalid_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#api_key_not_found */\n  API_KEY_NOT_FOUND: \"api_key_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_uid */\n  IMMUTABLE_API_KEY_UID: \"immutable_api_key_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_actions */\n  IMMUTABLE_API_KEY_ACTIONS: \"immutable_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_indexes */\n  IMMUTABLE_API_KEY_INDEXES: \"immutable_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_expires_at */\n  IMMUTABLE_API_KEY_EXPIRES_AT: \"immutable_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_created_at */\n  IMMUTABLE_API_KEY_CREATED_AT: \"immutable_api_key_created_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_updated_at */\n  IMMUTABLE_API_KEY_UPDATED_AT: \"immutable_api_key_updated_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_authorization_header */\n  MISSING_AUTHORIZATION_HEADER: \"missing_authorization_header\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#unretrievable_document */\n  UNRETRIEVABLE_DOCUMENT: \"unretrievable_document\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#database_size_limit_reached */\n  MAX_DATABASE_SIZE_LIMIT_REACHED: \"database_size_limit_reached\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#task_not_found */\n  TASK_NOT_FOUND: \"task_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_process_failed */\n  DUMP_PROCESS_FAILED: \"dump_process_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_not_found */\n  DUMP_NOT_FOUND: \"dump_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_duplicate_index_found */\n  INVALID_SWAP_DUPLICATE_INDEX_FOUND: \"invalid_swap_duplicate_index_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_indexes */\n  INVALID_SWAP_INDEXES: \"invalid_swap_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_swap_indexes */\n  MISSING_SWAP_INDEXES: \"missing_swap_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_master_key */\n  MISSING_MASTER_KEY: \"missing_master_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_types */\n  INVALID_TASK_TYPES: \"invalid_task_types\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_uids */\n  INVALID_TASK_UIDS: \"invalid_task_uids\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_statuses */\n  INVALID_TASK_STATUSES: \"invalid_task_statuses\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_limit */\n  INVALID_TASK_LIMIT: \"invalid_task_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_from */\n  INVALID_TASK_FROM: \"invalid_task_from\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_canceled_by */\n  INVALID_TASK_CANCELED_BY: \"invalid_task_canceled_by\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_task_filters */\n  MISSING_TASK_FILTERS: \"missing_task_filters\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#too_many_open_files */\n  TOO_MANY_OPEN_FILES: \"too_many_open_files\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#io_error */\n  IO_ERROR: \"io_error\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_index_uids */\n  INVALID_TASK_INDEX_UIDS: \"invalid_task_index_uids\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_uid */\n  IMMUTABLE_INDEX_UID: \"immutable_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_created_at */\n  IMMUTABLE_INDEX_CREATED_AT: \"immutable_index_created_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_updated_at */\n  IMMUTABLE_INDEX_UPDATED_AT: \"immutable_index_updated_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_displayed_attributes */\n  INVALID_SETTINGS_DISPLAYED_ATTRIBUTES:\n    \"invalid_settings_displayed_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_searchable_attributes */\n  INVALID_SETTINGS_SEARCHABLE_ATTRIBUTES:\n    \"invalid_settings_searchable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_filterable_attributes */\n  INVALID_SETTINGS_FILTERABLE_ATTRIBUTES:\n    \"invalid_settings_filterable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_sortable_attributes */\n  INVALID_SETTINGS_SORTABLE_ATTRIBUTES: \"invalid_settings_sortable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_ranking_rules */\n  INVALID_SETTINGS_RANKING_RULES: \"invalid_settings_ranking_rules\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_stop_words */\n  INVALID_SETTINGS_STOP_WORDS: \"invalid_settings_stop_words\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_synonyms */\n  INVALID_SETTINGS_SYNONYMS: \"invalid_settings_synonyms\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_distinct_attribute */\n  INVALID_SETTINGS_DISTINCT_ATTRIBUTE: \"invalid_settings_distinct_attribute\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_typo_tolerance */\n  INVALID_SETTINGS_TYPO_TOLERANCE: \"invalid_settings_typo_tolerance\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_faceting */\n  INVALID_SETTINGS_FACETING: \"invalid_settings_faceting\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_pagination */\n  INVALID_SETTINGS_PAGINATION: \"invalid_settings_pagination\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_search_cutoff_ms */\n  INVALID_SETTINGS_SEARCH_CUTOFF_MS: \"invalid_settings_search_cutoff_ms\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_search_cutoff_ms */\n  INVALID_SETTINGS_LOCALIZED_ATTRIBUTES:\n    \"invalid_settings_localized_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_enqueued_at */\n  INVALID_TASK_BEFORE_ENQUEUED_AT: \"invalid_task_before_enqueued_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_enqueued_at */\n  INVALID_TASK_AFTER_ENQUEUED_AT: \"invalid_task_after_enqueued_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_started_at */\n  INVALID_TASK_BEFORE_STARTED_AT: \"invalid_task_before_started_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_started_at */\n  INVALID_TASK_AFTER_STARTED_AT: \"invalid_task_after_started_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_finished_at */\n  INVALID_TASK_BEFORE_FINISHED_AT: \"invalid_task_before_finished_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_finished_at */\n  INVALID_TASK_AFTER_FINISHED_AT: \"invalid_task_after_finished_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_actions */\n  MISSING_API_KEY_ACTIONS: \"missing_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_indexes */\n  MISSING_API_KEY_INDEXES: \"missing_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_expires_at */\n  MISSING_API_KEY_EXPIRES_AT: \"missing_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_limit */\n  INVALID_API_KEY_LIMIT: \"invalid_api_key_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_offset */\n  INVALID_API_KEY_OFFSET: \"invalid_api_key_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_name */\n  INVALID_FACET_SEARCH_FACET_NAME: \"invalid_facet_search_facet_name\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_facet_search_facet_name */\n  MISSING_FACET_SEARCH_FACET_NAME: \"missing_facet_search_facet_name\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_query */\n  INVALID_FACET_SEARCH_FACET_QUERY: \"invalid_facet_search_facet_query\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_ranking_score_threshold */\n  INVALID_SEARCH_RANKING_SCORE_THRESHOLD:\n    \"invalid_search_ranking_score_threshold\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_similar_ranking_score_threshold */\n  INVALID_SIMILAR_RANKING_SCORE_THRESHOLD:\n    \"invalid_similar_ranking_score_threshold\",\n};\n\nexport type ErrorStatusCode =\n  (typeof ErrorStatusCode)[keyof typeof ErrorStatusCode];\n\n/** @see {@link TokenSearchRules} */\nexport type TokenIndexRules = { filter?: Filter };\n\n/**\n * {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#search-rules}\n *\n * @remarks\n * Not well documented.\n * @see {@link https://github.com/meilisearch/meilisearch/blob/b21d7aedf9096539041362d438e973a18170f3fc/crates/meilisearch-auth/src/lib.rs#L271-L277 | GitHub source code}\n */\nexport type TokenSearchRules =\n  | Record<string, TokenIndexRules | null>\n  | string[];\n\n/** Options object for tenant token generation. */\nexport type TenantTokenGeneratorOptions = {\n  /** API key used to sign the token. */\n  apiKey: string;\n  /**\n   * The uid of the api key used as issuer of the token.\n   *\n   * @see {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#api-key-uid}\n   */\n  apiKeyUid: string;\n  /**\n   * Search rules that are applied to every search.\n   *\n   * @defaultValue `[\"*\"]`\n   */\n  searchRules?: TokenSearchRules;\n  /**\n   * {@link https://en.wikipedia.org/wiki/Unix_time | UNIX timestamp} or\n   * {@link Date} object at which the token expires.\n   *\n   * @see {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#expiry-date}\n   */\n  expiresAt?: number | Date;\n  /**\n   * Encryption algorithm used to sign the JWT. Supported values by Meilisearch\n   * are HS256, HS384, HS512. (HS[number] means HMAC using SHA-[number])\n   *\n   * @defaultValue `\"HS256\"`\n   * @see {@link https://www.meilisearch.com/docs/learn/security/generate_tenant_token_scratch#prepare-token-header}\n   */\n  algorithm?: `HS${256 | 384 | 512}`;\n  /**\n   * By default if a non-safe environment is detected, an error is thrown.\n   * Setting this to `true` skips environment detection. This is intended for\n   * server-side environments where detection fails or usage in a browser is\n   * intentional (Use at your own risk).\n   *\n   * @defaultValue `false`\n   */\n  force?: boolean;\n};\n","/*\n * Bundle: MeiliSearch / Indexes\n * Project: MeiliSearch - Javascript API\n * Author: Quentin de Quelen <quentin@meilisearch.com>\n * Copyright: 2019, MeiliSearch\n */\n\nimport {\n  MeiliSearchError,\n  MeiliSearchRequestError,\n  versionErrorHintMessage,\n  MeiliSearchApiError,\n} from \"./errors/index.js\";\nimport type {\n  Config,\n  SearchResponse,\n  SearchParams,\n  Filter,\n  SearchRequestGET,\n  IndexObject,\n  IndexOptions,\n  IndexStats,\n  DocumentsQuery,\n  DocumentQuery,\n  DocumentOptions,\n  Settings,\n  Synonyms,\n  StopWords,\n  RankingRules,\n  DistinctAttribute,\n  FilterableAttributes,\n  SortableAttributes,\n  SearchableAttributes,\n  DisplayedAttributes,\n  TypoTolerance,\n  WaitOptions,\n  TasksQuery,\n  TasksResults,\n  PaginationSettings,\n  Faceting,\n  ResourceResults,\n  RawDocumentAdditionOptions,\n  ContentType,\n  DocumentsIds,\n  DocumentsDeletionQuery,\n  SearchForFacetValuesParams,\n  SearchForFacetValuesResponse,\n  SeparatorTokens,\n  NonSeparatorTokens,\n  Dictionary,\n  ProximityPrecision,\n  Embedders,\n  SearchCutoffMs,\n  SearchSimilarDocumentsParams,\n  LocalizedAttributes,\n  UpdateDocumentsByFunctionOptions,\n  PrefixSearch,\n} from \"./types.js\";\nimport { removeUndefinedFromObject } from \"./utils.js\";\nimport { HttpRequests } from \"./http-requests.js\";\nimport { Task, TaskClient } from \"./task.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\n\nclass Index<T extends Record<string, any> = Record<string, any>> {\n  uid: string;\n  primaryKey: string | undefined;\n  createdAt: Date | undefined;\n  updatedAt: Date | undefined;\n  httpRequest: HttpRequests;\n  tasks: TaskClient;\n\n  /**\n   * @param config - Request configuration options\n   * @param uid - UID of the index\n   * @param primaryKey - Primary Key of the index\n   */\n  constructor(config: Config, uid: string, primaryKey?: string) {\n    this.uid = uid;\n    this.primaryKey = primaryKey;\n    this.httpRequest = new HttpRequests(config);\n    this.tasks = new TaskClient(config);\n  }\n\n  ///\n  /// SEARCH\n  ///\n\n  /**\n   * Search for documents into an index\n   *\n   * @param query - Query string\n   * @param options - Search options\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async search<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(\n    query?: string | null,\n    options?: S,\n    config?: Partial<Request>,\n  ): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/search`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject({ q: query, ...options }),\n      undefined,\n      config,\n    );\n  }\n\n  /**\n   * Search for documents into an index using the GET method\n   *\n   * @param query - Query string\n   * @param options - Search options\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async searchGet<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(\n    query?: string | null,\n    options?: S,\n    config?: Partial<Request>,\n  ): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/search`;\n\n    const parseFilter = (filter?: Filter): string | undefined => {\n      if (typeof filter === \"string\") return filter;\n      else if (Array.isArray(filter))\n        throw new MeiliSearchError(\n          \"The filter query parameter should be in string format when using searchGet\",\n        );\n      else return undefined;\n    };\n\n    const getParams: SearchRequestGET = {\n      q: query,\n      ...options,\n      filter: parseFilter(options?.filter),\n      sort: options?.sort?.join(\",\"),\n      facets: options?.facets?.join(\",\"),\n      attributesToRetrieve: options?.attributesToRetrieve?.join(\",\"),\n      attributesToCrop: options?.attributesToCrop?.join(\",\"),\n      attributesToHighlight: options?.attributesToHighlight?.join(\",\"),\n      vector: options?.vector?.join(\",\"),\n      attributesToSearchOn: options?.attributesToSearchOn?.join(\",\"),\n    };\n\n    return await this.httpRequest.get<SearchResponse<D, S>>(\n      url,\n      removeUndefinedFromObject(getParams),\n      config,\n    );\n  }\n\n  /**\n   * Search for facet values\n   *\n   * @param params - Parameters used to search on the facets\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async searchForFacetValues(\n    params: SearchForFacetValuesParams,\n    config?: Partial<Request>,\n  ): Promise<SearchForFacetValuesResponse> {\n    const url = `indexes/${this.uid}/facet-search`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject(params),\n      undefined,\n      config,\n    );\n  }\n\n  /**\n   * Search for similar documents\n   *\n   * @param params - Parameters used to search for similar documents\n   * @returns Promise containing the search response\n   */\n  async searchSimilarDocuments<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(params: SearchSimilarDocumentsParams): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/similar`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject(params),\n      undefined,\n    );\n  }\n\n  ///\n  /// INDEX\n  ///\n\n  /**\n   * Get index information.\n   *\n   * @returns Promise containing index information\n   */\n  async getRawInfo(): Promise<IndexObject> {\n    const url = `indexes/${this.uid}`;\n    const res = await this.httpRequest.get<IndexObject>(url);\n    this.primaryKey = res.primaryKey;\n    this.updatedAt = new Date(res.updatedAt);\n    this.createdAt = new Date(res.createdAt);\n    return res;\n  }\n\n  /**\n   * Fetch and update Index information.\n   *\n   * @returns Promise to the current Index object with updated information\n   */\n  async fetchInfo(): Promise<this> {\n    await this.getRawInfo();\n    return this;\n  }\n\n  /**\n   * Get Primary Key.\n   *\n   * @returns Promise containing the Primary Key of the index\n   */\n  async fetchPrimaryKey(): Promise<string | undefined> {\n    this.primaryKey = (await this.getRawInfo()).primaryKey;\n    return this.primaryKey;\n  }\n\n  /**\n   * Create an index.\n   *\n   * @param uid - Unique identifier of the Index\n   * @param options - Index options\n   * @param config - Request configuration options\n   * @returns Newly created Index object\n   */\n  static async create(\n    uid: string,\n    options: IndexOptions = {},\n    config: Config,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes`;\n    const req = new HttpRequests(config);\n    const task = await req.post(url, { ...options, uid });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Update an index.\n   *\n   * @param data - Data to update\n   * @returns Promise to the current Index object with updated information\n   */\n  async update(data: IndexOptions): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}`;\n    const task = await this.httpRequest.patch(url, data);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Delete an index.\n   *\n   * @returns Promise which resolves when index is deleted successfully\n   */\n  async delete(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// TASKS\n  ///\n\n  /**\n   * Get the list of all the tasks of the index.\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise containing all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    return await this.tasks.getTasks({ ...parameters, indexUids: [this.uid] });\n  }\n\n  /**\n   * Get one task of the index.\n   *\n   * @param taskUid - Task identifier\n   * @returns Promise containing a task\n   */\n  async getTask(taskUid: number): Promise<Task> {\n    return await this.tasks.getTask(taskUid);\n  }\n\n  /**\n   * Wait for multiple tasks to be processed.\n   *\n   * @param taskUids - Tasks identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise containing an array of tasks\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    return await this.tasks.waitForTasks(taskUids, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Wait for a task to be processed.\n   *\n   * @param taskUid - Task identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise containing an array of tasks\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    return await this.tasks.waitForTask(taskUid, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  ///\n  /// STATS\n  ///\n\n  /**\n   * Get stats of an index\n   *\n   * @returns Promise containing object with stats of the index\n   */\n  async getStats(): Promise<IndexStats> {\n    const url = `indexes/${this.uid}/stats`;\n    return await this.httpRequest.get<IndexStats>(url);\n  }\n\n  ///\n  /// DOCUMENTS\n  ///\n\n  /**\n   * Get documents of an index.\n   *\n   * @param parameters - Parameters to browse the documents. Parameters can\n   *   contain the `filter` field only available in Meilisearch v1.2 and newer\n   * @returns Promise containing the returned documents\n   */\n  async getDocuments<D extends Record<string, any> = T>(\n    parameters: DocumentsQuery<D> = {},\n  ): Promise<ResourceResults<D[]>> {\n    parameters = removeUndefinedFromObject(parameters);\n\n    // In case `filter` is provided, use `POST /documents/fetch`\n    if (parameters.filter !== undefined) {\n      try {\n        const url = `indexes/${this.uid}/documents/fetch`;\n\n        return await this.httpRequest.post<\n          DocumentsQuery,\n          Promise<ResourceResults<D[]>>\n        >(url, parameters);\n      } catch (e) {\n        if (e instanceof MeiliSearchRequestError) {\n          e.message = versionErrorHintMessage(e.message, \"getDocuments\");\n        } else if (e instanceof MeiliSearchApiError) {\n          e.message = versionErrorHintMessage(e.message, \"getDocuments\");\n        }\n\n        throw e;\n      }\n      // Else use `GET /documents` method\n    } else {\n      const url = `indexes/${this.uid}/documents`;\n\n      // Transform fields to query parameter string format\n      const fields = Array.isArray(parameters?.fields)\n        ? { fields: parameters?.fields?.join(\",\") }\n        : {};\n\n      return await this.httpRequest.get<Promise<ResourceResults<D[]>>>(url, {\n        ...parameters,\n        ...fields,\n      });\n    }\n  }\n\n  /**\n   * Get one document\n   *\n   * @param documentId - Document ID\n   * @param parameters - Parameters applied on a document\n   * @returns Promise containing Document response\n   */\n  async getDocument<D extends Record<string, any> = T>(\n    documentId: string | number,\n    parameters?: DocumentQuery<T>,\n  ): Promise<D> {\n    const url = `indexes/${this.uid}/documents/${documentId}`;\n\n    const fields = (() => {\n      if (Array.isArray(parameters?.fields)) {\n        return parameters?.fields?.join(\",\");\n      }\n      return undefined;\n    })();\n\n    return await this.httpRequest.get<D>(\n      url,\n      removeUndefinedFromObject({\n        ...parameters,\n        fields,\n      }),\n    );\n  }\n\n  /**\n   * Add or replace multiples documents to an index\n   *\n   * @param documents - Array of Document objects to add/replace\n   * @param options - Options on document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async addDocuments(\n    documents: T[],\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.post(url, documents, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or replace multiples documents in a string format to an index. It only\n   * supports csv, ndjson and json formats.\n   *\n   * @param documents - Documents provided in a string to add/replace\n   * @param contentType - Content type of your document:\n   *   'text/csv'|'application/x-ndjson'|'application/json'\n   * @param options - Options on document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async addDocumentsFromString(\n    documents: string,\n    contentType: ContentType,\n    queryParams?: RawDocumentAdditionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n\n    const task = await this.httpRequest.post(url, documents, queryParams, {\n      headers: {\n        \"Content-Type\": contentType,\n      },\n    });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or replace multiples documents to an index in batches\n   *\n   * @param documents - Array of Document objects to add/replace\n   * @param batchSize - Size of the batch\n   * @param options - Options on document addition\n   * @returns Promise containing array of enqueued task objects for each batch\n   */\n  async addDocumentsInBatches(\n    documents: T[],\n    batchSize = 1000,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask[]> {\n    const updates = [];\n    for (let i = 0; i < documents.length; i += batchSize) {\n      updates.push(\n        await this.addDocuments(documents.slice(i, i + batchSize), options),\n      );\n    }\n    return updates;\n  }\n\n  /**\n   * Add or update multiples documents to an index\n   *\n   * @param documents - Array of Document objects to add/update\n   * @param options - Options on document update\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocuments(\n    documents: Array<Partial<T>>,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.put(url, documents, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or update multiples documents to an index in batches\n   *\n   * @param documents - Array of Document objects to add/update\n   * @param batchSize - Size of the batch\n   * @param options - Options on document update\n   * @returns Promise containing array of enqueued task objects for each batch\n   */\n  async updateDocumentsInBatches(\n    documents: Array<Partial<T>>,\n    batchSize = 1000,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask[]> {\n    const updates = [];\n    for (let i = 0; i < documents.length; i += batchSize) {\n      updates.push(\n        await this.updateDocuments(documents.slice(i, i + batchSize), options),\n      );\n    }\n    return updates;\n  }\n\n  /**\n   * Add or update multiples documents in a string format to an index. It only\n   * supports csv, ndjson and json formats.\n   *\n   * @param documents - Documents provided in a string to add/update\n   * @param contentType - Content type of your document:\n   *   'text/csv'|'application/x-ndjson'|'application/json'\n   * @param queryParams - Options on raw document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocumentsFromString(\n    documents: string,\n    contentType: ContentType,\n    queryParams?: RawDocumentAdditionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n\n    const task = await this.httpRequest.put(url, documents, queryParams, {\n      headers: {\n        \"Content-Type\": contentType,\n      },\n    });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Delete one document\n   *\n   * @param documentId - Id of Document to delete\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteDocument(documentId: string | number): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents/${documentId}`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Delete multiples documents of an index.\n   *\n   * @param params - Params value can be:\n   *\n   *   - DocumentsDeletionQuery: An object containing the parameters to customize\n   *       your document deletion. Only available in Meilisearch v1.2 and newer\n   *   - DocumentsIds: An array of document ids to delete\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteDocuments(\n    params: DocumentsDeletionQuery | DocumentsIds,\n  ): Promise<EnqueuedTask> {\n    // If params is of type DocumentsDeletionQuery\n    const isDocumentsDeletionQuery =\n      !Array.isArray(params) && typeof params === \"object\";\n    const endpoint = isDocumentsDeletionQuery\n      ? \"documents/delete\"\n      : \"documents/delete-batch\";\n    const url = `indexes/${this.uid}/${endpoint}`;\n\n    try {\n      const task = await this.httpRequest.post(url, params);\n\n      return new EnqueuedTask(task);\n    } catch (e) {\n      if (e instanceof MeiliSearchRequestError && isDocumentsDeletionQuery) {\n        e.message = versionErrorHintMessage(e.message, \"deleteDocuments\");\n      } else if (e instanceof MeiliSearchApiError) {\n        e.message = versionErrorHintMessage(e.message, \"deleteDocuments\");\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Delete all documents of an index\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteAllDocuments(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * This is an EXPERIMENTAL feature, which may break without a major version.\n   * It's available after Meilisearch v1.10.\n   *\n   * More info about the feature:\n   * https://github.com/orgs/meilisearch/discussions/762 More info about\n   * experimental features in general:\n   * https://www.meilisearch.com/docs/reference/api/experimental-features\n   *\n   * @param options - Object containing the function string and related options\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocumentsByFunction(\n    options: UpdateDocumentsByFunctionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents/edit`;\n    const task = await this.httpRequest.post(url, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SETTINGS\n  ///\n\n  /**\n   * Retrieve all settings\n   *\n   * @returns Promise containing Settings object\n   */\n  async getSettings(): Promise<Settings> {\n    const url = `indexes/${this.uid}/settings`;\n    return await this.httpRequest.get<Settings>(url);\n  }\n\n  /**\n   * Update all settings Any parameters not provided will be left unchanged.\n   *\n   * @param settings - Object containing parameters with their updated values\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSettings(settings: Settings): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings`;\n    const task = await this.httpRequest.patch(url, settings);\n\n    task.enqueued = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Reset settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSettings(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// PAGINATION SETTINGS\n  ///\n\n  /**\n   * Get the pagination settings.\n   *\n   * @returns Promise containing object of pagination settings\n   */\n  async getPagination(): Promise<PaginationSettings> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    return await this.httpRequest.get<object>(url);\n  }\n\n  /**\n   * Update the pagination settings.\n   *\n   * @param pagination - Pagination object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updatePagination(\n    pagination: PaginationSettings,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    const task = await this.httpRequest.patch(url, pagination);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the pagination settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetPagination(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SYNONYMS\n  ///\n\n  /**\n   * Get the list of all synonyms\n   *\n   * @returns Promise containing object of synonym mappings\n   */\n  async getSynonyms(): Promise<object> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    return await this.httpRequest.get<object>(url);\n  }\n\n  /**\n   * Update the list of synonyms. Overwrite the old list.\n   *\n   * @param synonyms - Mapping of synonyms with their associated words\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSynonyms(synonyms: Synonyms): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    const task = await this.httpRequest.put(url, synonyms);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the synonym list to be empty again\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSynonyms(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// STOP WORDS\n  ///\n\n  /**\n   * Get the list of all stop-words\n   *\n   * @returns Promise containing array of stop-words\n   */\n  async getStopWords(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of stop-words. Overwrite the old list.\n   *\n   * @param stopWords - Array of strings that contains the stop-words.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateStopWords(stopWords: StopWords): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    const task = await this.httpRequest.put(url, stopWords);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the stop-words list to be empty again\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetStopWords(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// RANKING RULES\n  ///\n\n  /**\n   * Get the list of all ranking-rules\n   *\n   * @returns Promise containing array of ranking-rules\n   */\n  async getRankingRules(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of ranking-rules. Overwrite the old list.\n   *\n   * @param rankingRules - Array that contain ranking rules sorted by order of\n   *   importance.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateRankingRules(rankingRules: RankingRules): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    const task = await this.httpRequest.put(url, rankingRules);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the ranking rules list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetRankingRules(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DISTINCT ATTRIBUTE\n  ///\n\n  /**\n   * Get the distinct-attribute\n   *\n   * @returns Promise containing the distinct-attribute of the index\n   */\n  async getDistinctAttribute(): Promise<string | null> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    return await this.httpRequest.get<string | null>(url);\n  }\n\n  /**\n   * Update the distinct-attribute.\n   *\n   * @param distinctAttribute - Field name of the distinct-attribute\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDistinctAttribute(\n    distinctAttribute: DistinctAttribute,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    const task = await this.httpRequest.put(url, distinctAttribute);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the distinct-attribute.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDistinctAttribute(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// FILTERABLE ATTRIBUTES\n  ///\n\n  /**\n   * Get the filterable-attributes\n   *\n   * @returns Promise containing an array of filterable-attributes\n   */\n  async getFilterableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the filterable-attributes.\n   *\n   * @param filterableAttributes - Array of strings containing the attributes\n   *   that can be used as filters at query time\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFilterableAttributes(\n    filterableAttributes: FilterableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    const task = await this.httpRequest.put(url, filterableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the filterable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFilterableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SORTABLE ATTRIBUTES\n  ///\n\n  /**\n   * Get the sortable-attributes\n   *\n   * @returns Promise containing array of sortable-attributes\n   */\n  async getSortableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the sortable-attributes.\n   *\n   * @param sortableAttributes - Array of strings containing the attributes that\n   *   can be used to sort search results at query time\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSortableAttributes(\n    sortableAttributes: SortableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    const task = await this.httpRequest.put(url, sortableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the sortable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSortableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SEARCHABLE ATTRIBUTE\n  ///\n\n  /**\n   * Get the searchable-attributes\n   *\n   * @returns Promise containing array of searchable-attributes\n   */\n  async getSearchableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the searchable-attributes.\n   *\n   * @param searchableAttributes - Array of strings that contains searchable\n   *   attributes sorted by order of importance(most to least important)\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSearchableAttributes(\n    searchableAttributes: SearchableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    const task = await this.httpRequest.put(url, searchableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the searchable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSearchableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DISPLAYED ATTRIBUTE\n  ///\n\n  /**\n   * Get the displayed-attributes\n   *\n   * @returns Promise containing array of displayed-attributes\n   */\n  async getDisplayedAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the displayed-attributes.\n   *\n   * @param displayedAttributes - Array of strings that contains attributes of\n   *   an index to display\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDisplayedAttributes(\n    displayedAttributes: DisplayedAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    const task = await this.httpRequest.put(url, displayedAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the displayed-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDisplayedAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// TYPO TOLERANCE\n  ///\n\n  /**\n   * Get the typo tolerance settings.\n   *\n   * @returns Promise containing the typo tolerance settings.\n   */\n  async getTypoTolerance(): Promise<TypoTolerance> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    return await this.httpRequest.get<TypoTolerance>(url);\n  }\n\n  /**\n   * Update the typo tolerance settings.\n   *\n   * @param typoTolerance - Object containing the custom typo tolerance\n   *   settings.\n   * @returns Promise containing object of the enqueued update\n   */\n  async updateTypoTolerance(\n    typoTolerance: TypoTolerance,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    const task = await this.httpRequest.patch(url, typoTolerance);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Reset the typo tolerance settings.\n   *\n   * @returns Promise containing object of the enqueued update\n   */\n  async resetTypoTolerance(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// FACETING\n  ///\n\n  /**\n   * Get the faceting settings.\n   *\n   * @returns Promise containing object of faceting index settings\n   */\n  async getFaceting(): Promise<Faceting> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    return await this.httpRequest.get<Faceting>(url);\n  }\n\n  /**\n   * Update the faceting settings.\n   *\n   * @param faceting - Faceting index settings object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFaceting(faceting: Faceting): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    const task = await this.httpRequest.patch(url, faceting);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the faceting settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFaceting(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SEPARATOR TOKENS\n  ///\n\n  /**\n   * Get the list of all separator tokens.\n   *\n   * @returns Promise containing array of separator tokens\n   */\n  async getSeparatorTokens(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of separator tokens. Overwrite the old list.\n   *\n   * @param separatorTokens - Array that contains separator tokens.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateSeparatorTokens(\n    separatorTokens: SeparatorTokens,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    const task = await this.httpRequest.put(url, separatorTokens);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the separator tokens list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSeparatorTokens(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// NON-SEPARATOR TOKENS\n  ///\n\n  /**\n   * Get the list of all non-separator tokens.\n   *\n   * @returns Promise containing array of non-separator tokens\n   */\n  async getNonSeparatorTokens(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of non-separator tokens. Overwrite the old list.\n   *\n   * @param nonSeparatorTokens - Array that contains non-separator tokens.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateNonSeparatorTokens(\n    nonSeparatorTokens: NonSeparatorTokens,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    const task = await this.httpRequest.put(url, nonSeparatorTokens);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the non-separator tokens list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetNonSeparatorTokens(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DICTIONARY\n  ///\n\n  /**\n   * Get the dictionary settings of a Meilisearch index.\n   *\n   * @returns Promise containing the dictionary settings\n   */\n  async getDictionary(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the dictionary settings. Overwrite the old settings.\n   *\n   * @param dictionary - Array that contains the new dictionary settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateDictionary(dictionary: Dictionary): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    const task = await this.httpRequest.put(url, dictionary);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the dictionary settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDictionary(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// PROXIMITY PRECISION\n  ///\n\n  /**\n   * Get the proximity precision settings of a Meilisearch index.\n   *\n   * @returns Promise containing the proximity precision settings\n   */\n  async getProximityPrecision(): Promise<ProximityPrecision> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    return await this.httpRequest.get<ProximityPrecision>(url);\n  }\n\n  /**\n   * Update the proximity precision settings. Overwrite the old settings.\n   *\n   * @param proximityPrecision - String that contains the new proximity\n   *   precision settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateProximityPrecision(\n    proximityPrecision: ProximityPrecision,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    const task = await this.httpRequest.put(url, proximityPrecision);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the proximity precision settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetProximityPrecision(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// EMBEDDERS\n  ///\n\n  /**\n   * Get the embedders settings of a Meilisearch index.\n   *\n   * @returns Promise containing the embedders settings\n   */\n  async getEmbedders(): Promise<Embedders> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    return await this.httpRequest.get<Embedders>(url);\n  }\n\n  /**\n   * Update the embedders settings. Overwrite the old settings.\n   *\n   * @param embedders - Object that contains the new embedders settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateEmbedders(embedders: Embedders): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    const task = await this.httpRequest.patch(url, embedders);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the embedders settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetEmbedders(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SEARCHCUTOFFMS SETTINGS\n  ///\n\n  /**\n   * Get the SearchCutoffMs settings.\n   *\n   * @returns Promise containing object of SearchCutoffMs settings\n   */\n  async getSearchCutoffMs(): Promise<SearchCutoffMs> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    return await this.httpRequest.get<SearchCutoffMs>(url);\n  }\n\n  /**\n   * Update the SearchCutoffMs settings.\n   *\n   * @param searchCutoffMs - Object containing SearchCutoffMsSettings\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSearchCutoffMs(\n    searchCutoffMs: SearchCutoffMs,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    const task = await this.httpRequest.put(url, searchCutoffMs);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the SearchCutoffMs settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSearchCutoffMs(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// LOCALIZED ATTRIBUTES SETTINGS\n  ///\n\n  /**\n   * Get the localized attributes settings.\n   *\n   * @returns Promise containing object of localized attributes settings\n   */\n  async getLocalizedAttributes(): Promise<LocalizedAttributes> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    return await this.httpRequest.get<LocalizedAttributes>(url);\n  }\n\n  /**\n   * Update the localized attributes settings.\n   *\n   * @param localizedAttributes - Localized attributes object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateLocalizedAttributes(\n    localizedAttributes: LocalizedAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    const task = await this.httpRequest.put(url, localizedAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the localized attributes settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetLocalizedAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// FACET SEARCH SETTINGS\n  ///\n\n  /**\n   * Get the facet search settings.\n   *\n   * @returns Promise containing object of facet search settings\n   */\n  async getFacetSearch(): Promise<boolean> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    return await this.httpRequest.get<boolean>(url);\n  }\n\n  /**\n   * Update the facet search settings.\n   *\n   * @param facetSearch - Boolean value\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFacetSearch(facetSearch: boolean): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    const task = await this.httpRequest.put(url, facetSearch);\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the facet search settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFacetSearch(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    const task = await this.httpRequest.delete(url);\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// PREFIX SEARCH SETTINGS\n  ///\n\n  /**\n   * Get the prefix search settings.\n   *\n   * @returns Promise containing object of prefix search settings\n   */\n  async getPrefixSearch(): Promise<PrefixSearch> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    return await this.httpRequest.get<PrefixSearch>(url);\n  }\n\n  /**\n   * Update the prefix search settings.\n   *\n   * @param prefixSearch - PrefixSearch value\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updatePrefixSearch(prefixSearch: PrefixSearch): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    const task = await this.httpRequest.put(url, prefixSearch);\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the prefix search settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetPrefixSearch(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    const task = await this.httpRequest.delete(url);\n    return new EnqueuedTask(task);\n  }\n}\n\nexport { Index };\n","/*\n * Bundle: MeiliSearch\n * Project: MeiliSearch - Javascript API\n * Author: Quentin de Quelen <quentin@meilisearch.com>\n * Copyright: 2019, MeiliSearch\n */\n\nimport { Index } from \"./indexes.js\";\nimport type {\n  KeyCreation,\n  Config,\n  IndexOptions,\n  IndexObject,\n  Key,\n  Health,\n  Stats,\n  Version,\n  TasksQuery,\n  WaitOptions,\n  KeyUpdate,\n  IndexesQuery,\n  IndexesResults,\n  KeysQuery,\n  KeysResults,\n  TasksResults,\n  EnqueuedTaskObject,\n  SwapIndexesParams,\n  CancelTasksQuery,\n  DeleteTasksQuery,\n  MultiSearchParams,\n  FederatedMultiSearchParams,\n  BatchesResults,\n  BatchesQuery,\n  MultiSearchResponseOrSearchResponse,\n} from \"./types.js\";\nimport { ErrorStatusCode } from \"./types.js\";\nimport { HttpRequests } from \"./http-requests.js\";\nimport { TaskClient, type Task } from \"./task.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\nimport { type Batch, BatchClient } from \"./batch.js\";\n\nexport class MeiliSearch {\n  config: Config;\n  httpRequest: HttpRequests;\n  tasks: TaskClient;\n  batches: BatchClient;\n\n  /**\n   * Creates new MeiliSearch instance\n   *\n   * @param config - Configuration object\n   */\n  constructor(config: Config) {\n    this.config = config;\n    this.httpRequest = new HttpRequests(config);\n    this.tasks = new TaskClient(config);\n    this.batches = new BatchClient(config);\n  }\n\n  /**\n   * Return an Index instance\n   *\n   * @param indexUid - The index UID\n   * @returns Instance of Index\n   */\n  index<T extends Record<string, any> = Record<string, any>>(\n    indexUid: string,\n  ): Index<T> {\n    return new Index<T>(this.config, indexUid);\n  }\n\n  /**\n   * Gather information about an index by calling MeiliSearch and return an\n   * Index instance with the gathered information\n   *\n   * @param indexUid - The index UID\n   * @returns Promise returning Index instance\n   */\n  async getIndex<T extends Record<string, any> = Record<string, any>>(\n    indexUid: string,\n  ): Promise<Index<T>> {\n    return new Index<T>(this.config, indexUid).fetchInfo();\n  }\n\n  /**\n   * Gather information about an index by calling MeiliSearch and return the raw\n   * JSON response\n   *\n   * @param indexUid - The index UID\n   * @returns Promise returning index information\n   */\n  async getRawIndex(indexUid: string): Promise<IndexObject> {\n    return new Index(this.config, indexUid).getRawInfo();\n  }\n\n  /**\n   * Get all the indexes as Index instances.\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning array of raw index information\n   */\n  async getIndexes(\n    parameters: IndexesQuery = {},\n  ): Promise<IndexesResults<Index[]>> {\n    const rawIndexes = await this.getRawIndexes(parameters);\n    const indexes: Index[] = rawIndexes.results.map(\n      (index) => new Index(this.config, index.uid, index.primaryKey),\n    );\n    return { ...rawIndexes, results: indexes };\n  }\n\n  /**\n   * Get all the indexes in their raw value (no Index instances).\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning array of raw index information\n   */\n  async getRawIndexes(\n    parameters: IndexesQuery = {},\n  ): Promise<IndexesResults<IndexObject[]>> {\n    const url = `indexes`;\n    return await this.httpRequest.get<IndexesResults<IndexObject[]>>(\n      url,\n      parameters,\n    );\n  }\n\n  /**\n   * Create a new index\n   *\n   * @param uid - The index UID\n   * @param options - Index options\n   * @returns Promise returning Index instance\n   */\n  async createIndex(\n    uid: string,\n    options: IndexOptions = {},\n  ): Promise<EnqueuedTask> {\n    return await Index.create(uid, options, this.config);\n  }\n\n  /**\n   * Update an index\n   *\n   * @param uid - The index UID\n   * @param options - Index options to update\n   * @returns Promise returning Index instance after updating\n   */\n  async updateIndex(\n    uid: string,\n    options: IndexOptions = {},\n  ): Promise<EnqueuedTask> {\n    return await new Index(this.config, uid).update(options);\n  }\n\n  /**\n   * Delete an index\n   *\n   * @param uid - The index UID\n   * @returns Promise which resolves when index is deleted successfully\n   */\n  async deleteIndex(uid: string): Promise<EnqueuedTask> {\n    return await new Index(this.config, uid).delete();\n  }\n\n  /**\n   * Deletes an index if it already exists.\n   *\n   * @param uid - The index UID\n   * @returns Promise which resolves to true when index exists and is deleted\n   *   successfully, otherwise false if it does not exist\n   */\n  async deleteIndexIfExists(uid: string): Promise<boolean> {\n    try {\n      await this.deleteIndex(uid);\n      return true;\n    } catch (e: any) {\n      if (e.code === ErrorStatusCode.INDEX_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Swaps a list of index tuples.\n   *\n   * @param params - List of indexes tuples to swap.\n   * @returns Promise returning object of the enqueued task\n   */\n  async swapIndexes(params: SwapIndexesParams): Promise<EnqueuedTask> {\n    const url = \"/swap-indexes\";\n    return await this.httpRequest.post(url, params);\n  }\n\n  ///\n  /// Multi Search\n  ///\n\n  /**\n   * Perform multiple search queries.\n   *\n   * It is possible to make multiple search queries on the same index or on\n   * different ones\n   *\n   * @example\n   *\n   * ```ts\n   * client.multiSearch({\n   *   queries: [\n   *     { indexUid: \"movies\", q: \"wonder\" },\n   *     { indexUid: \"books\", q: \"flower\" },\n   *   ],\n   * });\n   * ```\n   *\n   * @param queries - Search queries\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search responses\n   */\n  async multiSearch<\n    T1 extends MultiSearchParams | FederatedMultiSearchParams,\n    T2 extends Record<string, unknown> = Record<string, any>,\n  >(\n    queries: T1,\n    config?: Partial<Request>,\n  ): Promise<MultiSearchResponseOrSearchResponse<T1, T2>> {\n    const url = `multi-search`;\n\n    return await this.httpRequest.post(url, queries, undefined, config);\n  }\n\n  ///\n  /// TASKS\n  ///\n\n  /**\n   * Get the list of all client tasks\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise returning all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    return await this.tasks.getTasks(parameters);\n  }\n\n  /**\n   * Get one task on the client scope\n   *\n   * @param taskUid - Task identifier\n   * @returns Promise returning a task\n   */\n  async getTask(taskUid: number): Promise<Task> {\n    return await this.tasks.getTask(taskUid);\n  }\n\n  /**\n   * Wait for multiple tasks to be finished.\n   *\n   * @param taskUids - Tasks identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise returning an array of tasks\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    return await this.tasks.waitForTasks(taskUids, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Wait for a task to be finished.\n   *\n   * @param taskUid - Task identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise returning an array of tasks\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    return await this.tasks.waitForTask(taskUid, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Cancel a list of enqueued or processing tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async cancelTasks(parameters: CancelTasksQuery): Promise<EnqueuedTask> {\n    return await this.tasks.cancelTasks(parameters);\n  }\n\n  /**\n   * Delete a list of tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteTasks(parameters: DeleteTasksQuery = {}): Promise<EnqueuedTask> {\n    return await this.tasks.deleteTasks(parameters);\n  }\n\n  /**\n   * Get all the batches\n   *\n   * @param parameters - Parameters to browse the batches\n   * @returns Promise returning all batches\n   */\n  async getBatches(parameters: BatchesQuery = {}): Promise<BatchesResults> {\n    return await this.batches.getBatches(parameters);\n  }\n\n  /**\n   * Get one batch\n   *\n   * @param uid - Batch identifier\n   * @returns Promise returning a batch\n   */\n  async getBatch(uid: number): Promise<Batch> {\n    return await this.batches.getBatch(uid);\n  }\n\n  ///\n  /// KEYS\n  ///\n\n  /**\n   * Get all API keys\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning an object with keys\n   */\n  async getKeys(parameters: KeysQuery = {}): Promise<KeysResults> {\n    const url = `keys`;\n    const keys = await this.httpRequest.get<KeysResults>(url, parameters);\n\n    keys.results = keys.results.map((key) => ({\n      ...key,\n      createdAt: new Date(key.createdAt),\n      updatedAt: new Date(key.updatedAt),\n    }));\n\n    return keys;\n  }\n\n  /**\n   * Get one API key\n   *\n   * @param keyOrUid - Key or uid of the API key\n   * @returns Promise returning a key\n   */\n  async getKey(keyOrUid: string): Promise<Key> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.get<Key>(url);\n  }\n\n  /**\n   * Create one API key\n   *\n   * @param options - Key options\n   * @returns Promise returning a key\n   */\n  async createKey(options: KeyCreation): Promise<Key> {\n    const url = `keys`;\n    return await this.httpRequest.post(url, options);\n  }\n\n  /**\n   * Update one API key\n   *\n   * @param keyOrUid - Key\n   * @param options - Key options\n   * @returns Promise returning a key\n   */\n  async updateKey(keyOrUid: string, options: KeyUpdate): Promise<Key> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.patch(url, options);\n  }\n\n  /**\n   * Delete one API key\n   *\n   * @param keyOrUid - Key\n   * @returns\n   */\n  async deleteKey(keyOrUid: string): Promise<void> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.delete<any>(url);\n  }\n\n  ///\n  /// HEALTH\n  ///\n\n  /**\n   * Checks if the server is healthy, otherwise an error will be thrown.\n   *\n   * @returns Promise returning an object with health details\n   */\n  async health(): Promise<Health> {\n    const url = `health`;\n    return await this.httpRequest.get<Health>(url);\n  }\n\n  /**\n   * Checks if the server is healthy, return true or false.\n   *\n   * @returns Promise returning a boolean\n   */\n  async isHealthy(): Promise<boolean> {\n    try {\n      const url = `health`;\n      await this.httpRequest.get(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  ///\n  /// STATS\n  ///\n\n  /**\n   * Get the stats of all the database\n   *\n   * @returns Promise returning object of all the stats\n   */\n  async getStats(): Promise<Stats> {\n    const url = `stats`;\n    return await this.httpRequest.get<Stats>(url);\n  }\n\n  ///\n  /// VERSION\n  ///\n\n  /**\n   * Get the version of MeiliSearch\n   *\n   * @returns Promise returning object with version details\n   */\n  async getVersion(): Promise<Version> {\n    const url = `version`;\n    return await this.httpRequest.get<Version>(url);\n  }\n\n  ///\n  /// DUMPS\n  ///\n\n  /**\n   * Creates a dump\n   *\n   * @returns Promise returning object of the enqueued task\n   */\n  async createDump(): Promise<EnqueuedTask> {\n    const url = `dumps`;\n    const task = await this.httpRequest.post<undefined, EnqueuedTaskObject>(\n      url,\n    );\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SNAPSHOTS\n  ///\n\n  /**\n   * Creates a snapshot\n   *\n   * @returns Promise returning object of the enqueued task\n   */\n  async createSnapshot(): Promise<EnqueuedTask> {\n    const url = `snapshots`;\n    const task = await this.httpRequest.post<undefined, EnqueuedTaskObject>(\n      url,\n    );\n\n    return new EnqueuedTask(task);\n  }\n}\n","export * from \"./types.js\";\nexport * from \"./errors/index.js\";\nexport * from \"./indexes.js\";\nexport * from \"./enqueued-task.js\";\nexport * from \"./task.js\";\nimport { MeiliSearch } from \"./meilisearch.js\";\n\n/**\n * Default export of {@link MeiliSearch}.\n *\n * @deprecated The default export will be removed in a future version.\n *   {@link https://github.com/meilisearch/meilisearch-js/issues/1789 | Issue}.\n */\nconst defaultExport = MeiliSearch;\n\nexport { MeiliSearch, MeiliSearch as Meilisearch };\nexport default defaultExport;\n"],"names":["reject"],"mappings":"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"}