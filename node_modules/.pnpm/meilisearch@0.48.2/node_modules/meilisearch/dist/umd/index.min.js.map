{"version":3,"file":"index.min.js","sources":["../../src/errors/meilisearch-error.ts","../../src/errors/meilisearch-api-error.ts","../../src/errors/meilisearch-request-error.ts","../../src/errors/meilisearch-timeout-error.ts","../../src/errors/version-hint-message.ts","../../src/package-version.ts","../../src/utils.ts","../../src/http-requests.ts","../../src/enqueued-task.ts","../../src/task.ts","../../src/batch.ts","../../src/types.ts","../../src/indexes.ts","../../src/meilisearch.ts","../../src/index.ts"],"sourcesContent":["export class MeiliSearchError extends Error {\n  override name = \"MeiliSearchError\";\n\n  constructor(...params: ConstructorParameters<typeof Error>) {\n    super(...params);\n  }\n}\n","import type { MeiliSearchErrorResponse } from \"../types.js\";\nimport { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchApiError extends MeiliSearchError {\n  override name = \"MeiliSearchApiError\";\n  override cause?: MeiliSearchErrorResponse;\n  readonly response: Response;\n\n  constructor(response: Response, responseBody?: MeiliSearchErrorResponse) {\n    super(\n      responseBody?.message ?? `${response.status}: ${response.statusText}`,\n    );\n\n    this.response = response;\n\n    if (responseBody !== undefined) {\n      this.cause = responseBody;\n    }\n  }\n}\n","import { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchRequestError extends MeiliSearchError {\n  override name = \"MeiliSearchRequestError\";\n\n  constructor(url: string, cause: unknown) {\n    super(`Request to ${url} has failed`, { cause });\n  }\n}\n","import { MeiliSearchError } from \"./meilisearch-error.js\";\n\nexport class MeiliSearchTimeOutError extends MeiliSearchError {\n  override name = \"MeiliSearchTimeOutError\";\n\n  constructor(message: string) {\n    super(message);\n  }\n}\n","export function versionErrorHintMessage(message: string, method: string) {\n  return `${message}\\nHint: It might not be working because maybe you're not up to date with the Meilisearch version that ${method} call requires.`;\n}\n","export const PACKAGE_VERSION = \"0.48.2\";\n","/** Removes undefined entries from object */\nfunction removeUndefinedFromObject(obj: Record<string, any>): object {\n  return Object.entries(obj).reduce(\n    (acc, curEntry) => {\n      const [key, val] = curEntry;\n      if (val !== undefined) acc[key] = val;\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n}\n\nasync function sleep(ms: number): Promise<void> {\n  return await new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nfunction addProtocolIfNotPresent(host: string): string {\n  if (!(host.startsWith(\"https://\") || host.startsWith(\"http://\"))) {\n    return `http://${host}`;\n  }\n  return host;\n}\n\nfunction addTrailingSlash(url: string): string {\n  if (!url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\n\nexport {\n  sleep,\n  removeUndefinedFromObject,\n  addProtocolIfNotPresent,\n  addTrailingSlash,\n};\n","import type { Config, EnqueuedTaskObject } from \"./types.js\";\nimport { PACKAGE_VERSION } from \"./package-version.js\";\n\nimport {\n  MeiliSearchError,\n  MeiliSearchApiError,\n  MeiliSearchRequestError,\n} from \"./errors/index.js\";\n\nimport { addTrailingSlash, addProtocolIfNotPresent } from \"./utils.js\";\n\ntype queryParams<T> = { [key in keyof T]: string };\n\nfunction toQueryParams<T extends object>(parameters: T): queryParams<T> {\n  const params = Object.keys(parameters) as Array<keyof T>;\n\n  const queryParams = params.reduce<queryParams<T>>((acc, key) => {\n    const value = parameters[key];\n    if (value === undefined) {\n      return acc;\n    } else if (Array.isArray(value)) {\n      return { ...acc, [key]: value.join(\",\") };\n    } else if (value instanceof Date) {\n      return { ...acc, [key]: value.toISOString() };\n    }\n    return { ...acc, [key]: value };\n  }, {} as queryParams<T>);\n  return queryParams;\n}\n\nfunction constructHostURL(host: string): string {\n  try {\n    host = addProtocolIfNotPresent(host);\n    host = addTrailingSlash(host);\n    return host;\n  } catch {\n    throw new MeiliSearchError(\"The provided host is not valid.\");\n  }\n}\n\nfunction cloneAndParseHeaders(headers: HeadersInit): Record<string, string> {\n  if (Array.isArray(headers)) {\n    return headers.reduce(\n      (acc, headerPair) => {\n        acc[headerPair[0]] = headerPair[1];\n        return acc;\n      },\n      {} as Record<string, string>,\n    );\n  } else if (\"has\" in headers) {\n    const clonedHeaders: Record<string, string> = {};\n    (headers as Headers).forEach((value, key) => (clonedHeaders[key] = value));\n    return clonedHeaders;\n  } else {\n    return Object.assign({}, headers);\n  }\n}\n\nfunction createHeaders(config: Config): Record<string, any> {\n  const agentHeader = \"X-Meilisearch-Client\";\n  const packageAgent = `Meilisearch JavaScript (v${PACKAGE_VERSION})`;\n  const contentType = \"Content-Type\";\n  const authorization = \"Authorization\";\n  const headers = cloneAndParseHeaders(config.requestConfig?.headers ?? {});\n\n  // do not override if user provided the header\n  if (config.apiKey && !headers[authorization]) {\n    headers[authorization] = `Bearer ${config.apiKey}`;\n  }\n\n  if (!headers[contentType]) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n\n  // Creates the custom user agent with information on the package used.\n  if (config.clientAgents && Array.isArray(config.clientAgents)) {\n    const clients = config.clientAgents.concat(packageAgent);\n\n    headers[agentHeader] = clients.join(\" ; \");\n  } else if (config.clientAgents && !Array.isArray(config.clientAgents)) {\n    // If the header is defined but not an array\n    throw new MeiliSearchError(\n      `Meilisearch: The header \"${agentHeader}\" should be an array of string(s).\\n`,\n    );\n  } else {\n    headers[agentHeader] = packageAgent;\n  }\n\n  return headers;\n}\n\nclass HttpRequests {\n  headers: Record<string, any>;\n  url: URL;\n  requestConfig?: Config[\"requestConfig\"];\n  httpClient?: Required<Config>[\"httpClient\"];\n  requestTimeout?: number;\n\n  constructor(config: Config) {\n    this.headers = createHeaders(config);\n    this.requestConfig = config.requestConfig;\n    this.httpClient = config.httpClient;\n    this.requestTimeout = config.timeout;\n\n    try {\n      const host = constructHostURL(config.host);\n      this.url = new URL(host);\n    } catch {\n      throw new MeiliSearchError(\"The provided host is not valid.\");\n    }\n  }\n\n  async request({\n    method,\n    url,\n    params,\n    body,\n    config = {},\n  }: {\n    method: string;\n    url: string;\n    params?: { [key: string]: any };\n    body?: any;\n    config?: Record<string, any>;\n  }) {\n    const constructURL = new URL(url, this.url);\n    if (params) {\n      const queryParams = new URLSearchParams();\n      Object.keys(params)\n        .filter((x: string) => params[x] !== null)\n        .map((x: string) => queryParams.set(x, params[x]));\n      constructURL.search = queryParams.toString();\n    }\n\n    // in case a custom content-type is provided\n    // do not stringify body\n    if (!config.headers?.[\"Content-Type\"]) {\n      body = JSON.stringify(body);\n    }\n\n    const headers = { ...this.headers, ...config.headers };\n    const responsePromise = this.fetchWithTimeout(\n      constructURL.toString(),\n      {\n        ...config,\n        ...this.requestConfig,\n        method,\n        body,\n        headers,\n      },\n      this.requestTimeout,\n    );\n\n    const response = await responsePromise.catch((error: unknown) => {\n      throw new MeiliSearchRequestError(constructURL.toString(), error);\n    });\n\n    // When using a custom HTTP client, the response is returned to allow the user to parse/handle it as they see fit\n    if (this.httpClient !== undefined) {\n      return response;\n    }\n\n    const responseBody = await response.text();\n    const parsedResponse =\n      responseBody === \"\" ? undefined : JSON.parse(responseBody);\n\n    if (!response.ok) {\n      throw new MeiliSearchApiError(response, parsedResponse);\n    }\n\n    return parsedResponse;\n  }\n\n  async fetchWithTimeout(\n    url: string,\n    options: Record<string, any> | RequestInit | undefined,\n    timeout: HttpRequests[\"requestTimeout\"],\n  ): Promise<Response> {\n    return new Promise((resolve, reject) => {\n      const fetchFn = this.httpClient ? this.httpClient : fetch;\n\n      const fetchPromise = fetchFn(url, options);\n\n      const promises: Array<Promise<any>> = [fetchPromise];\n\n      // TimeoutPromise will not run if undefined or zero\n      let timeoutId: ReturnType<typeof setTimeout>;\n      if (timeout) {\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(() => {\n            reject(new Error(\"Error: Request Timed Out\"));\n          }, timeout);\n        });\n\n        promises.push(timeoutPromise);\n      }\n\n      Promise.race(promises)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          clearTimeout(timeoutId);\n        });\n    });\n  }\n\n  async get(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<void>;\n\n  async get<T = any>(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<T>;\n\n  async get(\n    url: string,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"GET\",\n      url,\n      params,\n      config,\n    });\n  }\n\n  async post<T = any, R = EnqueuedTaskObject>(\n    url: string,\n    data?: T,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<R>;\n\n  async post(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"POST\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async put<T = any, R = EnqueuedTaskObject>(\n    url: string,\n    data?: T,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<R>;\n\n  async put(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"PUT\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async patch(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"PATCH\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n\n  async delete(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<EnqueuedTaskObject>;\n  async delete<T>(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<T>;\n  async delete(\n    url: string,\n    data?: any,\n    params?: { [key: string]: any },\n    config?: Record<string, any>,\n  ): Promise<any> {\n    return await this.request({\n      method: \"DELETE\",\n      url,\n      body: data,\n      params,\n      config,\n    });\n  }\n}\n\nexport { HttpRequests, toQueryParams };\n","import type { EnqueuedTaskObject } from \"./types.js\";\n\nclass EnqueuedTask {\n  taskUid: EnqueuedTaskObject[\"taskUid\"];\n  indexUid: EnqueuedTaskObject[\"indexUid\"];\n  status: EnqueuedTaskObject[\"status\"];\n  type: EnqueuedTaskObject[\"type\"];\n  enqueuedAt: Date;\n\n  constructor(task: EnqueuedTaskObject) {\n    this.taskUid = task.taskUid;\n    this.indexUid = task.indexUid;\n    this.status = task.status;\n    this.type = task.type;\n    this.enqueuedAt = new Date(task.enqueuedAt);\n  }\n}\n\nexport { EnqueuedTask };\n","import { MeiliSearchTimeOutError } from \"./errors/index.js\";\nimport type {\n  Config,\n  WaitOptions,\n  TasksQuery,\n  TasksResults,\n  TaskObject,\n  CancelTasksQuery,\n  TasksResultsObject,\n  DeleteTasksQuery,\n} from \"./types.js\";\nimport { TaskStatus } from \"./types.js\";\nimport { HttpRequests, toQueryParams } from \"./http-requests.js\";\nimport { sleep } from \"./utils.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\n\nclass Task {\n  indexUid: TaskObject[\"indexUid\"];\n  status: TaskObject[\"status\"];\n  type: TaskObject[\"type\"];\n  uid: TaskObject[\"uid\"];\n  batchUid: TaskObject[\"batchUid\"];\n  canceledBy: TaskObject[\"canceledBy\"];\n  details: TaskObject[\"details\"];\n  error: TaskObject[\"error\"];\n  duration: TaskObject[\"duration\"];\n  startedAt: Date;\n  enqueuedAt: Date;\n  finishedAt: Date;\n\n  constructor(task: TaskObject) {\n    this.indexUid = task.indexUid;\n    this.status = task.status;\n    this.type = task.type;\n    this.uid = task.uid;\n    this.batchUid = task.batchUid;\n    this.details = task.details;\n    this.canceledBy = task.canceledBy;\n    this.error = task.error;\n    this.duration = task.duration;\n\n    this.startedAt = new Date(task.startedAt);\n    this.enqueuedAt = new Date(task.enqueuedAt);\n    this.finishedAt = new Date(task.finishedAt);\n  }\n}\n\nclass TaskClient {\n  httpRequest: HttpRequests;\n\n  constructor(config: Config) {\n    this.httpRequest = new HttpRequests(config);\n  }\n\n  /**\n   * Get one task\n   *\n   * @param uid - Unique identifier of the task\n   * @returns\n   */\n  async getTask(uid: number): Promise<Task> {\n    const url = `tasks/${uid}`;\n    const taskItem = await this.httpRequest.get<TaskObject>(url);\n    return new Task(taskItem);\n  }\n\n  /**\n   * Get tasks\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise containing all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    const url = `tasks`;\n\n    const tasks = await this.httpRequest.get<Promise<TasksResultsObject>>(\n      url,\n      toQueryParams<TasksQuery>(parameters),\n    );\n\n    return {\n      ...tasks,\n      results: tasks.results.map((task) => new Task(task)),\n    };\n  }\n\n  /**\n   * Wait for a task to be processed.\n   *\n   * @param taskUid - Task identifier\n   * @param options - Additional configuration options\n   * @returns Promise returning a task after it has been processed\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    const startingTime = Date.now();\n    while (Date.now() - startingTime < timeOutMs) {\n      const response = await this.getTask(taskUid);\n      if (\n        !(\n          [\n            TaskStatus.TASK_ENQUEUED,\n            TaskStatus.TASK_PROCESSING,\n          ] as readonly string[]\n        ).includes(response.status)\n      )\n        return response;\n      await sleep(intervalMs);\n    }\n    throw new MeiliSearchTimeOutError(\n      `timeout of ${timeOutMs}ms has exceeded on process ${taskUid} when waiting a task to be resolved.`,\n    );\n  }\n\n  /**\n   * Waits for multiple tasks to be processed\n   *\n   * @param taskUids - Tasks identifier list\n   * @param options - Wait options\n   * @returns Promise returning a list of tasks after they have been processed\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    const tasks: Task[] = [];\n    for (const taskUid of taskUids) {\n      const task = await this.waitForTask(taskUid, {\n        timeOutMs,\n        intervalMs,\n      });\n      tasks.push(task);\n    }\n    return tasks;\n  }\n\n  /**\n   * Cancel a list of enqueued or processing tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async cancelTasks(parameters: CancelTasksQuery = {}): Promise<EnqueuedTask> {\n    const url = `tasks/cancel`;\n\n    const task = await this.httpRequest.post(\n      url,\n      {},\n      toQueryParams<CancelTasksQuery>(parameters),\n    );\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Delete a list tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteTasks(parameters: DeleteTasksQuery = {}): Promise<EnqueuedTask> {\n    const url = `tasks`;\n\n    const task = await this.httpRequest.delete(\n      url,\n      {},\n      toQueryParams<DeleteTasksQuery>(parameters),\n    );\n    return new EnqueuedTask(task);\n  }\n}\n\nexport { TaskClient, Task };\n","import type {\n  Config,\n  BatchObject,\n  BatchesQuery,\n  BatchesResults,\n  BatchesResultsObject,\n} from \"./types.js\";\nimport { HttpRequests, toQueryParams } from \"./http-requests.js\";\n\nclass Batch {\n  uid: BatchObject[\"uid\"];\n  details: BatchObject[\"details\"];\n  stats: BatchObject[\"stats\"];\n  startedAt: BatchObject[\"startedAt\"];\n  finishedAt: BatchObject[\"finishedAt\"];\n  duration: BatchObject[\"duration\"];\n  progress: BatchObject[\"progress\"];\n\n  constructor(batch: BatchObject) {\n    this.uid = batch.uid;\n    this.details = batch.details;\n    this.stats = batch.stats;\n    this.startedAt = batch.startedAt;\n    this.finishedAt = batch.finishedAt;\n    this.duration = batch.duration;\n    this.progress = batch.progress;\n  }\n}\n\nclass BatchClient {\n  httpRequest: HttpRequests;\n\n  constructor(config: Config) {\n    this.httpRequest = new HttpRequests(config);\n  }\n\n  /**\n   * Get one batch\n   *\n   * @param uid - Unique identifier of the batch\n   * @returns\n   */\n  async getBatch(uid: number): Promise<Batch> {\n    const url = `batches/${uid}`;\n    const batch = await this.httpRequest.get<BatchObject>(url);\n    return new Batch(batch);\n  }\n\n  /**\n   * Get batches\n   *\n   * @param parameters - Parameters to browse the batches\n   * @returns Promise containing all batches\n   */\n  async getBatches(parameters: BatchesQuery = {}): Promise<BatchesResults> {\n    const url = `batches`;\n\n    const batches = await this.httpRequest.get<Promise<BatchesResultsObject>>(\n      url,\n      toQueryParams<BatchesQuery>(parameters),\n    );\n\n    return {\n      ...batches,\n      results: batches.results.map((batch) => new Batch(batch)),\n    };\n  }\n}\n\nexport { BatchClient, Batch };\n","// Type definitions for meilisearch\n// Project: https://github.com/meilisearch/meilisearch-js\n// Definitions by: qdequele <quentin@meilisearch.com> <https://github.com/meilisearch>\n// Definitions: https://github.com/meilisearch/meilisearch-js\n// TypeScript Version: ^3.8.3\n\nimport { Task } from \"./task.js\";\nimport { Batch } from \"./batch.js\";\n\nexport type Config = {\n  host: string;\n  apiKey?: string;\n  clientAgents?: string[];\n  requestConfig?: Partial<Omit<RequestInit, \"body\" | \"method\">>;\n  httpClient?: (input: string, init?: RequestInit) => Promise<any>;\n  timeout?: number;\n};\n\n///\n/// Resources\n///\n\nexport type Pagination = {\n  offset?: number;\n  limit?: number;\n};\n\nexport type ResourceQuery = Pagination & {};\n\nexport type ResourceResults<T> = Pagination & {\n  results: T;\n  total: number;\n};\n\n///\n/// Indexes\n///\n\nexport type IndexOptions = {\n  primaryKey?: string;\n};\n\nexport type IndexObject = {\n  uid: string;\n  primaryKey?: string;\n  createdAt: Date;\n  updatedAt: Date;\n};\n\nexport type IndexesQuery = ResourceQuery & {};\n\nexport type IndexesResults<T> = ResourceResults<T> & {};\n\n/*\n * SEARCH PARAMETERS\n */\n\nexport const MatchingStrategies = {\n  ALL: \"all\",\n  LAST: \"last\",\n  FREQUENCY: \"frequency\",\n} as const;\n\nexport type MatchingStrategies =\n  (typeof MatchingStrategies)[keyof typeof MatchingStrategies];\n\nexport type Filter = string | Array<string | string[]>;\n\nexport type Query = {\n  q?: string | null;\n};\n\nexport type Highlight = {\n  attributesToHighlight?: string[];\n  highlightPreTag?: string;\n  highlightPostTag?: string;\n};\n\nexport type Crop = {\n  attributesToCrop?: string[];\n  cropLength?: number;\n  cropMarker?: string;\n};\n\n// `facetName` becomes mandatory when using `searchForFacetValues`\nexport type SearchForFacetValuesParams = Omit<SearchParams, \"facetName\"> & {\n  facetName: string;\n};\n\nexport type FacetHit = {\n  value: string;\n  count: number;\n};\n\nexport type SearchForFacetValuesResponse = {\n  facetHits: FacetHit[];\n  facetQuery: string | null;\n  processingTimeMs: number;\n};\n\nexport type HybridSearch = {\n  embedder: string;\n  semanticRatio?: number;\n};\n\n// https://www.meilisearch.com/docs/reference/api/settings#localized-attributes\nexport type Locale = string;\n\nexport type SearchParams = Query &\n  Pagination &\n  Highlight &\n  Crop & {\n    filter?: Filter;\n    sort?: string[];\n    facets?: string[];\n    attributesToRetrieve?: string[];\n    showMatchesPosition?: boolean;\n    matchingStrategy?: MatchingStrategies;\n    hitsPerPage?: number;\n    page?: number;\n    facetName?: string;\n    facetQuery?: string;\n    vector?: number[] | null;\n    showRankingScore?: boolean;\n    showRankingScoreDetails?: boolean;\n    rankingScoreThreshold?: number;\n    attributesToSearchOn?: string[] | null;\n    hybrid?: HybridSearch;\n    distinct?: string;\n    retrieveVectors?: boolean;\n    locales?: Locale[];\n  };\n\n// Search parameters for searches made with the GET method\n// Are different than the parameters for the POST method\nexport type SearchRequestGET = Pagination &\n  Query &\n  Omit<Highlight, \"attributesToHighlight\"> &\n  Omit<Crop, \"attributesToCrop\"> & {\n    filter?: string;\n    sort?: string;\n    facets?: string;\n    attributesToRetrieve?: string;\n    attributesToHighlight?: string;\n    attributesToCrop?: string;\n    showMatchesPosition?: boolean;\n    vector?: string | null;\n    attributesToSearchOn?: string | null;\n    hybridEmbedder?: string;\n    hybridSemanticRatio?: number;\n    rankingScoreThreshold?: number;\n    distinct?: string;\n    retrieveVectors?: boolean;\n    locales?: Locale[];\n  };\n\nexport type MergeFacets = {\n  maxValuesPerFacet?: number | null;\n};\n\nexport type FederationOptions = { weight: number };\nexport type MultiSearchFederation = {\n  limit?: number;\n  offset?: number;\n  facetsByIndex?: Record<string, string[]>;\n  mergeFacets?: MergeFacets | null;\n};\n\nexport type MultiSearchQuery = SearchParams & { indexUid: string };\nexport type MultiSearchQueryWithFederation = MultiSearchQuery & {\n  federationOptions?: FederationOptions;\n};\n\nexport type MultiSearchParams = {\n  queries: MultiSearchQuery[];\n};\nexport type FederatedMultiSearchParams = {\n  federation: MultiSearchFederation;\n  queries: MultiSearchQueryWithFederation[];\n};\n\nexport type CategoriesDistribution = {\n  [category: string]: number;\n};\n\nexport type Facet = string;\nexport type FacetDistribution = Record<Facet, CategoriesDistribution>;\nexport type MatchesPosition<T> = Partial<\n  Record<keyof T, Array<{ start: number; length: number; indices?: number[] }>>\n>;\n\nexport type RankingScoreDetails = {\n  words?: {\n    order: number;\n    matchingWords: number;\n    maxMatchingWords: number;\n    score: number;\n  };\n  typo?: {\n    order: number;\n    typoCount: number;\n    maxTypoCount: number;\n    score: number;\n  };\n  proximity?: {\n    order: number;\n    score: number;\n  };\n  attribute?: {\n    order: number;\n    attributes_ranking_order: number;\n    attributes_query_word_order: number;\n    score: number;\n  };\n  exactness?: {\n    order: number;\n    matchType: string;\n    score: number;\n  };\n  [key: string]: Record<string, any> | undefined;\n};\n\nexport type FederationDetails = {\n  indexUid: string;\n  queriesPosition: number;\n  weightedRankingScore: number;\n};\n\nexport type Hit<T = Record<string, any>> = T & {\n  _formatted?: Partial<T>;\n  _matchesPosition?: MatchesPosition<T>;\n  _rankingScore?: number;\n  _rankingScoreDetails?: RankingScoreDetails;\n  _federation?: FederationDetails;\n};\n\nexport type Hits<T = Record<string, any>> = Array<Hit<T>>;\n\nexport type FacetStat = { min: number; max: number };\nexport type FacetStats = Record<string, FacetStat>;\n\nexport type FacetsByIndex = Record<\n  string,\n  {\n    distribution: FacetDistribution;\n    stats: FacetStats;\n  }\n>;\n\nexport type SearchResponse<\n  T = Record<string, any>,\n  S extends SearchParams | undefined = undefined,\n> = {\n  hits: Hits<T>;\n  processingTimeMs: number;\n  query: string;\n  facetDistribution?: FacetDistribution;\n  facetStats?: FacetStats;\n  facetsByIndex?: FacetsByIndex;\n} & (undefined extends S\n  ? Partial<FinitePagination & InfinitePagination>\n  : true extends IsFinitePagination<NonNullable<S>>\n    ? FinitePagination\n    : InfinitePagination);\n\ntype FinitePagination = {\n  totalHits: number;\n  hitsPerPage: number;\n  page: number;\n  totalPages: number;\n};\ntype InfinitePagination = {\n  offset: number;\n  limit: number;\n  estimatedTotalHits: number;\n};\n\ntype IsFinitePagination<S extends SearchParams> = Or<\n  HasHitsPerPage<S>,\n  HasPage<S>\n>;\n\ntype Or<A extends boolean, B extends boolean> = true extends A\n  ? true\n  : true extends B\n    ? true\n    : false;\n\ntype HasHitsPerPage<S extends SearchParams> = undefined extends S[\"hitsPerPage\"]\n  ? false\n  : true;\n\ntype HasPage<S extends SearchParams> = undefined extends S[\"page\"]\n  ? false\n  : true;\n\nexport type MultiSearchResult<T> = SearchResponse<T> & { indexUid: string };\n\nexport type MultiSearchResponse<T = Record<string, any>> = {\n  results: Array<MultiSearchResult<T>>;\n};\n\nexport type MultiSearchResponseOrSearchResponse<\n  T1 extends FederatedMultiSearchParams | MultiSearchParams,\n  T2 extends Record<string, unknown> = Record<string, any>,\n> = T1 extends FederatedMultiSearchParams\n  ? SearchResponse<T2>\n  : MultiSearchResponse<T2>;\n\nexport type FieldDistribution = {\n  [field: string]: number;\n};\n\nexport type SearchSimilarDocumentsParams = {\n  id: string | number;\n  offset?: number;\n  limit?: number;\n  filter?: Filter;\n  embedder?: string;\n  attributesToRetrieve?: string[];\n  showRankingScore?: boolean;\n  showRankingScoreDetails?: boolean;\n  rankingScoreThreshold?: number;\n};\n\n/*\n ** Documents\n */\n\ntype Fields<T = Record<string, any>> =\n  | Array<Extract<keyof T, string>>\n  | Extract<keyof T, string>;\n\nexport type DocumentOptions = {\n  primaryKey?: string;\n};\n\nexport const ContentTypeEnum: Readonly<Record<string, ContentType>> = {\n  JSON: \"application/json\",\n  CSV: \"text/csv\",\n  NDJSON: \"application/x-ndjson\",\n};\n\nexport type ContentType =\n  | \"text/csv\"\n  | \"application/x-ndjson\"\n  | \"application/json\";\n\nexport type RawDocumentAdditionOptions = DocumentOptions & {\n  csvDelimiter?: string;\n};\n\nexport type DocumentsQuery<T = Record<string, any>> = ResourceQuery & {\n  fields?: Fields<T>;\n  filter?: Filter;\n  limit?: number;\n  offset?: number;\n  retrieveVectors?: boolean;\n};\n\nexport type DocumentQuery<T = Record<string, any>> = {\n  fields?: Fields<T>;\n};\n\nexport type DocumentsDeletionQuery = {\n  filter: Filter;\n};\n\nexport type DocumentsIds = string[] | number[];\n\nexport type UpdateDocumentsByFunctionOptions = {\n  function: string;\n  filter?: string | string[];\n  context?: Record<string, any>;\n};\n\n/*\n ** Settings\n */\n\nexport type FilterableAttributes = string[] | null;\nexport type DistinctAttribute = string | null;\nexport type SearchableAttributes = string[] | null;\nexport type SortableAttributes = string[] | null;\nexport type DisplayedAttributes = string[] | null;\nexport type RankingRules = string[] | null;\nexport type StopWords = string[] | null;\nexport type Synonyms = {\n  [field: string]: string[];\n} | null;\nexport type TypoTolerance = {\n  enabled?: boolean | null;\n  disableOnAttributes?: string[] | null;\n  disableOnWords?: string[] | null;\n  minWordSizeForTypos?: {\n    oneTypo?: number | null;\n    twoTypos?: number | null;\n  };\n} | null;\nexport type SeparatorTokens = string[] | null;\nexport type NonSeparatorTokens = string[] | null;\nexport type Dictionary = string[] | null;\nexport type ProximityPrecision = \"byWord\" | \"byAttribute\";\n\nexport type Distribution = {\n  mean: number;\n  sigma: number;\n};\n\nexport type OpenAiEmbedder = {\n  source: \"openAi\";\n  model?: string;\n  apiKey?: string;\n  documentTemplate?: string;\n  dimensions?: number;\n  distribution?: Distribution;\n  url?: string;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type HuggingFaceEmbedder = {\n  source: \"huggingFace\";\n  model?: string;\n  revision?: string;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type UserProvidedEmbedder = {\n  source: \"userProvided\";\n  dimensions: number;\n  distribution?: Distribution;\n  binaryQuantized?: boolean;\n};\n\nexport type RestEmbedder = {\n  source: \"rest\";\n  url: string;\n  apiKey?: string;\n  dimensions?: number;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  request: Record<string, any>;\n  response: Record<string, any>;\n  headers?: Record<string, string>;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type OllamaEmbedder = {\n  source: \"ollama\";\n  url?: string;\n  apiKey?: string;\n  model?: string;\n  documentTemplate?: string;\n  distribution?: Distribution;\n  dimensions?: number;\n  documentTemplateMaxBytes?: number;\n  binaryQuantized?: boolean;\n};\n\nexport type Embedder =\n  | OpenAiEmbedder\n  | HuggingFaceEmbedder\n  | UserProvidedEmbedder\n  | RestEmbedder\n  | OllamaEmbedder\n  | null;\n\nexport type Embedders = Record<string, Embedder> | null;\n\nexport type FacetOrder = \"alpha\" | \"count\";\n\nexport type Faceting = {\n  maxValuesPerFacet?: number | null;\n  sortFacetValuesBy?: Record<string, FacetOrder> | null;\n};\n\nexport type PaginationSettings = {\n  maxTotalHits?: number | null;\n};\n\nexport type SearchCutoffMs = number | null;\n\nexport type LocalizedAttribute = {\n  attributePatterns: string[];\n  locales: Locale[];\n};\n\nexport type LocalizedAttributes = LocalizedAttribute[] | null;\n\nexport type PrefixSearch = \"indexingTime\" | \"disabled\";\n\nexport type Settings = {\n  filterableAttributes?: FilterableAttributes;\n  distinctAttribute?: DistinctAttribute;\n  sortableAttributes?: SortableAttributes;\n  searchableAttributes?: SearchableAttributes;\n  displayedAttributes?: DisplayedAttributes;\n  rankingRules?: RankingRules;\n  stopWords?: StopWords;\n  synonyms?: Synonyms;\n  typoTolerance?: TypoTolerance;\n  faceting?: Faceting;\n  pagination?: PaginationSettings;\n  separatorTokens?: SeparatorTokens;\n  nonSeparatorTokens?: NonSeparatorTokens;\n  dictionary?: Dictionary;\n  proximityPrecision?: ProximityPrecision;\n  embedders?: Embedders;\n  searchCutoffMs?: SearchCutoffMs;\n  localizedAttributes?: LocalizedAttributes;\n\n  /**\n   * Enable facet searching on all the filters of an index (requires Meilisearch\n   * 1.12.0 or later)\n   */\n  facetSearch?: boolean;\n  /**\n   * Enable the ability to search a word by prefix on an index (requires\n   * Meilisearch 1.12.0 or later)\n   */\n  prefixSearch?: \"indexingTime\" | \"disabled\";\n};\n\n/*\n ** TASKS\n */\n\nexport const TaskStatus = {\n  TASK_SUCCEEDED: \"succeeded\",\n  TASK_PROCESSING: \"processing\",\n  TASK_FAILED: \"failed\",\n  TASK_ENQUEUED: \"enqueued\",\n  TASK_CANCELED: \"canceled\",\n} as const;\n\nexport type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];\n\nexport const TaskTypes = {\n  DOCUMENTS_ADDITION_OR_UPDATE: \"documentAdditionOrUpdate\",\n  DOCUMENT_DELETION: \"documentDeletion\",\n  DUMP_CREATION: \"dumpCreation\",\n  INDEX_CREATION: \"indexCreation\",\n  INDEX_DELETION: \"indexDeletion\",\n  INDEXES_SWAP: \"indexSwap\",\n  INDEX_UPDATE: \"indexUpdate\",\n  SETTINGS_UPDATE: \"settingsUpdate\",\n  SNAPSHOT_CREATION: \"snapshotCreation\",\n  TASK_CANCELATION: \"taskCancelation\",\n  TASK_DELETION: \"taskDeletion\",\n} as const;\n\nexport type TaskTypes = (typeof TaskTypes)[keyof typeof TaskTypes];\n\nexport type TasksQuery = {\n  indexUids?: string[];\n  uids?: number[];\n  types?: TaskTypes[];\n  statuses?: TaskStatus[];\n  canceledBy?: number[];\n  beforeEnqueuedAt?: Date;\n  afterEnqueuedAt?: Date;\n  beforeStartedAt?: Date;\n  afterStartedAt?: Date;\n  beforeFinishedAt?: Date;\n  afterFinishedAt?: Date;\n  limit?: number;\n  from?: number;\n  /**\n   * If true, the tasks are returned in reverse order (requires Meilisearch\n   * 1.12.0 or later)\n   */\n  reverse?: boolean;\n};\n\nexport type CancelTasksQuery = Omit<TasksQuery, \"limit\" | \"from\"> & {};\n\nexport type DeleteTasksQuery = Omit<TasksQuery, \"limit\" | \"from\"> & {};\n\nexport type EnqueuedTaskObject = {\n  taskUid: number;\n  indexUid?: string;\n  status: TaskStatus;\n  type: TaskTypes;\n  enqueuedAt: string;\n  canceledBy: number;\n};\n\nexport type TaskObject = Omit<EnqueuedTaskObject, \"taskUid\"> & {\n  uid: number;\n  /** The UID of the batch that the task belongs to (`null` for enqueued tasks) */\n  batchUid: number | null;\n  details: {\n    // Number of documents sent\n    receivedDocuments?: number;\n\n    // Number of documents successfully indexed/updated in Meilisearch\n    indexedDocuments?: number;\n\n    // Number of deleted documents\n    deletedDocuments?: number;\n\n    // Number of documents found on a batch-delete\n    providedIds?: number;\n\n    // Primary key on index creation\n    primaryKey?: string;\n\n    // Ranking rules on settings actions\n    rankingRules?: RankingRules;\n\n    // Searchable attributes on settings actions\n    searchableAttributes?: SearchableAttributes;\n\n    // Displayed attributes on settings actions\n    displayedAttributes?: DisplayedAttributes;\n\n    // Filterable attributes on settings actions\n    filterableAttributes?: FilterableAttributes;\n\n    // Sortable attributes on settings actions\n    sortableAttributes?: SortableAttributes;\n\n    // Stop words on settings actions\n    stopWords?: StopWords;\n\n    // Stop words on settings actions\n    synonyms?: Synonyms;\n\n    // Distinct attribute on settings actions\n    distinctAttribute?: DistinctAttribute;\n\n    // Object containing the payload originating the `indexSwap` task creation\n    swaps?: SwapIndexesParams;\n\n    // Number of tasks that matched the originalQuery filter\n    matchedTasks?: number;\n\n    // Number of tasks that were canceled\n    canceledTasks?: number;\n\n    // Number of tasks that were deleted\n    deletedTasks?: number;\n\n    // Query parameters used to filter the tasks\n    originalFilter?: string;\n  };\n  error: MeiliSearchErrorResponse | null;\n  duration: string;\n  startedAt: string;\n  finishedAt: string;\n};\n\nexport type SwapIndexesParams = Array<{\n  indexes: string[];\n}>;\n\ntype CursorResults<T> = {\n  results: T[];\n  limit: number;\n  from: number;\n  next: number;\n  total: number;\n};\n\nexport type TasksResults = CursorResults<Task>;\nexport type TasksResultsObject = CursorResults<TaskObject>;\n\nexport type WaitOptions = {\n  timeOutMs?: number;\n  intervalMs?: number;\n};\n\n/*\n ** BATCHES\n */\n\n/**\n * Represents a batch operation object containing information about tasks\n * processing\n */\nexport type BatchObject = {\n  /** Unique identifier for the batch */\n  uid: number;\n\n  /** Details about document processing */\n  details: {\n    /** Number of documents received in the batch */\n    receivedDocuments?: number;\n    /** Number of documents successfully indexed */\n    indexedDocuments?: number;\n    /** Number of documents deleted in the batch */\n    deletedDocuments?: number;\n  };\n\n  /** Progress and indexing step of the batch, null if the batch is finished */\n  progress: null | {\n    /** An array of all the steps currently being processed */\n    steps: Array<{\n      /**\n       * A string representing the name of the current step NOT stable. Only use\n       * for debugging purposes.\n       */\n      currentStep: string;\n      /** Number of finished tasks */\n      finished: number;\n      /** Total number of tasks to finish before moving to the next step */\n      total: number;\n    }>;\n    /** Percentage of progression of all steps currently being processed */\n    percentage: number;\n  };\n\n  /** Statistics about tasks within the batch */\n  stats: {\n    /** Total number of tasks in the batch */\n    totalNbTasks: number;\n    /** Count of tasks in each status */\n    status: {\n      /** Number of successfully completed tasks */\n      succeeded: number;\n      /** Number of failed tasks */\n      failed: number;\n      /** Number of canceled tasks */\n      canceled: number;\n      /** Number of tasks currently processing */\n      processing: number;\n      /** Number of tasks waiting to be processed */\n      enqueued: number;\n    };\n    /** Count of tasks by type */\n    types: Record<TaskTypes, number>;\n    /** Count of tasks by index UID */\n    indexUids: Record<string, number>;\n  };\n\n  /** Timestamp when the batch started processing (rfc3339 format) */\n  startedAt: string;\n  /** Timestamp when the batch finished processing (rfc3339 format) */\n  finishedAt: string;\n  /** Duration of batch processing */\n  duration: string;\n};\n\nexport type BatchesQuery = {\n  /** The batch should contain the specified task UIDs */\n  uids?: number[];\n  batchUids?: number[];\n  types?: TaskTypes[];\n  statuses?: TaskStatus[];\n  indexUids?: string[];\n  canceledBy?: number[];\n  beforeEnqueuedAt?: Date;\n  afterEnqueuedAt?: Date;\n  beforeStartedAt?: Date;\n  afterStartedAt?: Date;\n  beforeFinishedAt?: Date;\n  afterFinishedAt?: Date;\n  limit?: number;\n  from?: number;\n};\n\nexport type BatchesResults = CursorResults<Batch>;\nexport type BatchesResultsObject = CursorResults<BatchObject>;\n\n/*\n *** HEALTH\n */\n\nexport type Health = {\n  status: \"available\";\n};\n\n/*\n *** STATS\n */\n\nexport type IndexStats = {\n  numberOfDocuments: number;\n  isIndexing: boolean;\n  fieldDistribution: FieldDistribution;\n};\n\nexport type Stats = {\n  databaseSize: number;\n  lastUpdate: string;\n  indexes: {\n    [index: string]: IndexStats;\n  };\n};\n\n/*\n ** Keys\n */\n\nexport type Key = {\n  uid: string;\n  description: string;\n  name: string | null;\n  key: string;\n  actions: string[];\n  indexes: string[];\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n};\n\nexport type KeyCreation = {\n  uid?: string;\n  name?: string;\n  description?: string;\n  actions: string[];\n  indexes: string[];\n  expiresAt: Date | null;\n};\n\nexport type KeyUpdate = {\n  name?: string;\n  description?: string;\n};\n\nexport type KeysQuery = ResourceQuery & {};\n\nexport type KeysResults = ResourceResults<Key[]> & {};\n\n/*\n ** version\n */\nexport type Version = {\n  commitSha: string;\n  commitDate: string;\n  pkgVersion: string;\n};\n\n/*\n ** ERROR HANDLER\n */\n\nexport interface FetchError extends Error {\n  type: string;\n  errno: string;\n  code: string;\n}\n\nexport type MeiliSearchErrorResponse = {\n  message: string;\n  // https://www.meilisearch.com/docs/reference/errors/error_codes\n  code: string;\n  // https://www.meilisearch.com/docs/reference/errors/overview#errors\n  type: string;\n  link: string;\n};\n\n// @TODO: This doesn't seem to be up to date, and its usefullness comes into question.\nexport const ErrorStatusCode = {\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_creation_failed */\n  INDEX_CREATION_FAILED: \"index_creation_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_index_uid */\n  MISSING_INDEX_UID: \"missing_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_already_exists */\n  INDEX_ALREADY_EXISTS: \"index_already_exists\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_found */\n  INDEX_NOT_FOUND: \"index_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_uid */\n  INVALID_INDEX_UID: \"invalid_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_accessible */\n  INDEX_NOT_ACCESSIBLE: \"index_not_accessible\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_offset */\n  INVALID_INDEX_OFFSET: \"invalid_index_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_limit */\n  INVALID_INDEX_LIMIT: \"invalid_index_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_state */\n  INVALID_STATE: \"invalid_state\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#primary_key_inference_failed */\n  PRIMARY_KEY_INFERENCE_FAILED: \"primary_key_inference_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_primary_key_already_exists */\n  INDEX_PRIMARY_KEY_ALREADY_EXISTS: \"index_primary_key_already_exists\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_primary_key */\n  INVALID_INDEX_PRIMARY_KEY: \"invalid_index_primary_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#max_fields_limit_exceeded */\n  DOCUMENTS_FIELDS_LIMIT_REACHED: \"document_fields_limit_reached\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */\n  MISSING_DOCUMENT_ID: \"missing_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */\n  INVALID_DOCUMENT_ID: \"invalid_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_content_type */\n  INVALID_CONTENT_TYPE: \"invalid_content_type\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_content_type */\n  MISSING_CONTENT_TYPE: \"missing_content_type\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_fields */\n  INVALID_DOCUMENT_FIELDS: \"invalid_document_fields\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_limit */\n  INVALID_DOCUMENT_LIMIT: \"invalid_document_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_offset */\n  INVALID_DOCUMENT_OFFSET: \"invalid_document_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_filter */\n  INVALID_DOCUMENT_FILTER: \"invalid_document_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_filter */\n  MISSING_DOCUMENT_FILTER: \"missing_document_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_vectors_field */\n  INVALID_DOCUMENT_VECTORS_FIELD: \"invalid_document_vectors_field\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#payload_too_large */\n  PAYLOAD_TOO_LARGE: \"payload_too_large\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_payload */\n  MISSING_PAYLOAD: \"missing_payload\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#malformed_payload */\n  MALFORMED_PAYLOAD: \"malformed_payload\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#no_space_left_on_device */\n  NO_SPACE_LEFT_ON_DEVICE: \"no_space_left_on_device\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_store_file */\n  INVALID_STORE_FILE: \"invalid_store_file\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_ranking_rules */\n  INVALID_RANKING_RULES: \"missing_document_id\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_request */\n  INVALID_REQUEST: \"invalid_request\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_geo_field */\n  INVALID_DOCUMENT_GEO_FIELD: \"invalid_document_geo_field\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_q */\n  INVALID_SEARCH_Q: \"invalid_search_q\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_offset */\n  INVALID_SEARCH_OFFSET: \"invalid_search_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_limit */\n  INVALID_SEARCH_LIMIT: \"invalid_search_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_page */\n  INVALID_SEARCH_PAGE: \"invalid_search_page\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_hits_per_page */\n  INVALID_SEARCH_HITS_PER_PAGE: \"invalid_search_hits_per_page\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_retrieve */\n  INVALID_SEARCH_ATTRIBUTES_TO_RETRIEVE:\n    \"invalid_search_attributes_to_retrieve\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_crop */\n  INVALID_SEARCH_ATTRIBUTES_TO_CROP: \"invalid_search_attributes_to_crop\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_length */\n  INVALID_SEARCH_CROP_LENGTH: \"invalid_search_crop_length\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_highlight */\n  INVALID_SEARCH_ATTRIBUTES_TO_HIGHLIGHT:\n    \"invalid_search_attributes_to_highlight\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_show_matches_position */\n  INVALID_SEARCH_SHOW_MATCHES_POSITION: \"invalid_search_show_matches_position\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_filter */\n  INVALID_SEARCH_FILTER: \"invalid_search_filter\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_sort */\n  INVALID_SEARCH_SORT: \"invalid_search_sort\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_facets */\n  INVALID_SEARCH_FACETS: \"invalid_search_facets\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_pre_tag */\n  INVALID_SEARCH_HIGHLIGHT_PRE_TAG: \"invalid_search_highlight_pre_tag\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_post_tag */\n  INVALID_SEARCH_HIGHLIGHT_POST_TAG: \"invalid_search_highlight_post_tag\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_marker */\n  INVALID_SEARCH_CROP_MARKER: \"invalid_search_crop_marker\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_matching_strategy */\n  INVALID_SEARCH_MATCHING_STRATEGY: \"invalid_search_matching_strategy\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_vector */\n  INVALID_SEARCH_VECTOR: \"invalid_search_vector\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_search_on */\n  INVALID_SEARCH_ATTRIBUTES_TO_SEARCH_ON:\n    \"invalid_search_attributes_to_search_on\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#bad_request */\n  BAD_REQUEST: \"bad_request\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#document_not_found */\n  DOCUMENT_NOT_FOUND: \"document_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#internal */\n  INTERNAL: \"internal\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key */\n  INVALID_API_KEY: \"invalid_api_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_description */\n  INVALID_API_KEY_DESCRIPTION: \"invalid_api_key_description\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_actions */\n  INVALID_API_KEY_ACTIONS: \"invalid_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_indexes */\n  INVALID_API_KEY_INDEXES: \"invalid_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_expires_at */\n  INVALID_API_KEY_EXPIRES_AT: \"invalid_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#api_key_not_found */\n  API_KEY_NOT_FOUND: \"api_key_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_uid */\n  IMMUTABLE_API_KEY_UID: \"immutable_api_key_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_actions */\n  IMMUTABLE_API_KEY_ACTIONS: \"immutable_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_indexes */\n  IMMUTABLE_API_KEY_INDEXES: \"immutable_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_expires_at */\n  IMMUTABLE_API_KEY_EXPIRES_AT: \"immutable_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_created_at */\n  IMMUTABLE_API_KEY_CREATED_AT: \"immutable_api_key_created_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_updated_at */\n  IMMUTABLE_API_KEY_UPDATED_AT: \"immutable_api_key_updated_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_authorization_header */\n  MISSING_AUTHORIZATION_HEADER: \"missing_authorization_header\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#unretrievable_document */\n  UNRETRIEVABLE_DOCUMENT: \"unretrievable_document\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#database_size_limit_reached */\n  MAX_DATABASE_SIZE_LIMIT_REACHED: \"database_size_limit_reached\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#task_not_found */\n  TASK_NOT_FOUND: \"task_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_process_failed */\n  DUMP_PROCESS_FAILED: \"dump_process_failed\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_not_found */\n  DUMP_NOT_FOUND: \"dump_not_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_duplicate_index_found */\n  INVALID_SWAP_DUPLICATE_INDEX_FOUND: \"invalid_swap_duplicate_index_found\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_indexes */\n  INVALID_SWAP_INDEXES: \"invalid_swap_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_swap_indexes */\n  MISSING_SWAP_INDEXES: \"missing_swap_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_master_key */\n  MISSING_MASTER_KEY: \"missing_master_key\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_types */\n  INVALID_TASK_TYPES: \"invalid_task_types\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_uids */\n  INVALID_TASK_UIDS: \"invalid_task_uids\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_statuses */\n  INVALID_TASK_STATUSES: \"invalid_task_statuses\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_limit */\n  INVALID_TASK_LIMIT: \"invalid_task_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_from */\n  INVALID_TASK_FROM: \"invalid_task_from\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_canceled_by */\n  INVALID_TASK_CANCELED_BY: \"invalid_task_canceled_by\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_task_filters */\n  MISSING_TASK_FILTERS: \"missing_task_filters\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#too_many_open_files */\n  TOO_MANY_OPEN_FILES: \"too_many_open_files\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#io_error */\n  IO_ERROR: \"io_error\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_index_uids */\n  INVALID_TASK_INDEX_UIDS: \"invalid_task_index_uids\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_uid */\n  IMMUTABLE_INDEX_UID: \"immutable_index_uid\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_created_at */\n  IMMUTABLE_INDEX_CREATED_AT: \"immutable_index_created_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_updated_at */\n  IMMUTABLE_INDEX_UPDATED_AT: \"immutable_index_updated_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_displayed_attributes */\n  INVALID_SETTINGS_DISPLAYED_ATTRIBUTES:\n    \"invalid_settings_displayed_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_searchable_attributes */\n  INVALID_SETTINGS_SEARCHABLE_ATTRIBUTES:\n    \"invalid_settings_searchable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_filterable_attributes */\n  INVALID_SETTINGS_FILTERABLE_ATTRIBUTES:\n    \"invalid_settings_filterable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_sortable_attributes */\n  INVALID_SETTINGS_SORTABLE_ATTRIBUTES: \"invalid_settings_sortable_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_ranking_rules */\n  INVALID_SETTINGS_RANKING_RULES: \"invalid_settings_ranking_rules\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_stop_words */\n  INVALID_SETTINGS_STOP_WORDS: \"invalid_settings_stop_words\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_synonyms */\n  INVALID_SETTINGS_SYNONYMS: \"invalid_settings_synonyms\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_distinct_attribute */\n  INVALID_SETTINGS_DISTINCT_ATTRIBUTE: \"invalid_settings_distinct_attribute\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_typo_tolerance */\n  INVALID_SETTINGS_TYPO_TOLERANCE: \"invalid_settings_typo_tolerance\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_faceting */\n  INVALID_SETTINGS_FACETING: \"invalid_settings_faceting\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_pagination */\n  INVALID_SETTINGS_PAGINATION: \"invalid_settings_pagination\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_search_cutoff_ms */\n  INVALID_SETTINGS_SEARCH_CUTOFF_MS: \"invalid_settings_search_cutoff_ms\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_search_cutoff_ms */\n  INVALID_SETTINGS_LOCALIZED_ATTRIBUTES:\n    \"invalid_settings_localized_attributes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_enqueued_at */\n  INVALID_TASK_BEFORE_ENQUEUED_AT: \"invalid_task_before_enqueued_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_enqueued_at */\n  INVALID_TASK_AFTER_ENQUEUED_AT: \"invalid_task_after_enqueued_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_started_at */\n  INVALID_TASK_BEFORE_STARTED_AT: \"invalid_task_before_started_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_started_at */\n  INVALID_TASK_AFTER_STARTED_AT: \"invalid_task_after_started_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_finished_at */\n  INVALID_TASK_BEFORE_FINISHED_AT: \"invalid_task_before_finished_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_finished_at */\n  INVALID_TASK_AFTER_FINISHED_AT: \"invalid_task_after_finished_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_actions */\n  MISSING_API_KEY_ACTIONS: \"missing_api_key_actions\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_indexes */\n  MISSING_API_KEY_INDEXES: \"missing_api_key_indexes\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_expires_at */\n  MISSING_API_KEY_EXPIRES_AT: \"missing_api_key_expires_at\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_limit */\n  INVALID_API_KEY_LIMIT: \"invalid_api_key_limit\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_offset */\n  INVALID_API_KEY_OFFSET: \"invalid_api_key_offset\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_name */\n  INVALID_FACET_SEARCH_FACET_NAME: \"invalid_facet_search_facet_name\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_facet_search_facet_name */\n  MISSING_FACET_SEARCH_FACET_NAME: \"missing_facet_search_facet_name\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_query */\n  INVALID_FACET_SEARCH_FACET_QUERY: \"invalid_facet_search_facet_query\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_ranking_score_threshold */\n  INVALID_SEARCH_RANKING_SCORE_THRESHOLD:\n    \"invalid_search_ranking_score_threshold\",\n\n  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_similar_ranking_score_threshold */\n  INVALID_SIMILAR_RANKING_SCORE_THRESHOLD:\n    \"invalid_similar_ranking_score_threshold\",\n};\n\nexport type ErrorStatusCode =\n  (typeof ErrorStatusCode)[keyof typeof ErrorStatusCode];\n\n/** @see {@link TokenSearchRules} */\nexport type TokenIndexRules = { filter?: Filter };\n\n/**\n * {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#search-rules}\n *\n * @remarks\n * Not well documented.\n * @see {@link https://github.com/meilisearch/meilisearch/blob/b21d7aedf9096539041362d438e973a18170f3fc/crates/meilisearch-auth/src/lib.rs#L271-L277 | GitHub source code}\n */\nexport type TokenSearchRules =\n  | Record<string, TokenIndexRules | null>\n  | string[];\n\n/** Options object for tenant token generation. */\nexport type TenantTokenGeneratorOptions = {\n  /** API key used to sign the token. */\n  apiKey: string;\n  /**\n   * The uid of the api key used as issuer of the token.\n   *\n   * @see {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#api-key-uid}\n   */\n  apiKeyUid: string;\n  /**\n   * Search rules that are applied to every search.\n   *\n   * @defaultValue `[\"*\"]`\n   */\n  searchRules?: TokenSearchRules;\n  /**\n   * {@link https://en.wikipedia.org/wiki/Unix_time | UNIX timestamp} or\n   * {@link Date} object at which the token expires.\n   *\n   * @see {@link https://www.meilisearch.com/docs/learn/security/tenant_token_reference#expiry-date}\n   */\n  expiresAt?: number | Date;\n  /**\n   * Encryption algorithm used to sign the JWT. Supported values by Meilisearch\n   * are HS256, HS384, HS512. (HS[number] means HMAC using SHA-[number])\n   *\n   * @defaultValue `\"HS256\"`\n   * @see {@link https://www.meilisearch.com/docs/learn/security/generate_tenant_token_scratch#prepare-token-header}\n   */\n  algorithm?: `HS${256 | 384 | 512}`;\n  /**\n   * By default if a non-safe environment is detected, an error is thrown.\n   * Setting this to `true` skips environment detection. This is intended for\n   * server-side environments where detection fails or usage in a browser is\n   * intentional (Use at your own risk).\n   *\n   * @defaultValue `false`\n   */\n  force?: boolean;\n};\n","/*\n * Bundle: MeiliSearch / Indexes\n * Project: MeiliSearch - Javascript API\n * Author: Quentin de Quelen <quentin@meilisearch.com>\n * Copyright: 2019, MeiliSearch\n */\n\nimport {\n  MeiliSearchError,\n  MeiliSearchRequestError,\n  versionErrorHintMessage,\n  MeiliSearchApiError,\n} from \"./errors/index.js\";\nimport type {\n  Config,\n  SearchResponse,\n  SearchParams,\n  Filter,\n  SearchRequestGET,\n  IndexObject,\n  IndexOptions,\n  IndexStats,\n  DocumentsQuery,\n  DocumentQuery,\n  DocumentOptions,\n  Settings,\n  Synonyms,\n  StopWords,\n  RankingRules,\n  DistinctAttribute,\n  FilterableAttributes,\n  SortableAttributes,\n  SearchableAttributes,\n  DisplayedAttributes,\n  TypoTolerance,\n  WaitOptions,\n  TasksQuery,\n  TasksResults,\n  PaginationSettings,\n  Faceting,\n  ResourceResults,\n  RawDocumentAdditionOptions,\n  ContentType,\n  DocumentsIds,\n  DocumentsDeletionQuery,\n  SearchForFacetValuesParams,\n  SearchForFacetValuesResponse,\n  SeparatorTokens,\n  NonSeparatorTokens,\n  Dictionary,\n  ProximityPrecision,\n  Embedders,\n  SearchCutoffMs,\n  SearchSimilarDocumentsParams,\n  LocalizedAttributes,\n  UpdateDocumentsByFunctionOptions,\n  PrefixSearch,\n} from \"./types.js\";\nimport { removeUndefinedFromObject } from \"./utils.js\";\nimport { HttpRequests } from \"./http-requests.js\";\nimport { Task, TaskClient } from \"./task.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\n\nclass Index<T extends Record<string, any> = Record<string, any>> {\n  uid: string;\n  primaryKey: string | undefined;\n  createdAt: Date | undefined;\n  updatedAt: Date | undefined;\n  httpRequest: HttpRequests;\n  tasks: TaskClient;\n\n  /**\n   * @param config - Request configuration options\n   * @param uid - UID of the index\n   * @param primaryKey - Primary Key of the index\n   */\n  constructor(config: Config, uid: string, primaryKey?: string) {\n    this.uid = uid;\n    this.primaryKey = primaryKey;\n    this.httpRequest = new HttpRequests(config);\n    this.tasks = new TaskClient(config);\n  }\n\n  ///\n  /// SEARCH\n  ///\n\n  /**\n   * Search for documents into an index\n   *\n   * @param query - Query string\n   * @param options - Search options\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async search<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(\n    query?: string | null,\n    options?: S,\n    config?: Partial<Request>,\n  ): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/search`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject({ q: query, ...options }),\n      undefined,\n      config,\n    );\n  }\n\n  /**\n   * Search for documents into an index using the GET method\n   *\n   * @param query - Query string\n   * @param options - Search options\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async searchGet<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(\n    query?: string | null,\n    options?: S,\n    config?: Partial<Request>,\n  ): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/search`;\n\n    const parseFilter = (filter?: Filter): string | undefined => {\n      if (typeof filter === \"string\") return filter;\n      else if (Array.isArray(filter))\n        throw new MeiliSearchError(\n          \"The filter query parameter should be in string format when using searchGet\",\n        );\n      else return undefined;\n    };\n\n    const getParams: SearchRequestGET = {\n      q: query,\n      ...options,\n      filter: parseFilter(options?.filter),\n      sort: options?.sort?.join(\",\"),\n      facets: options?.facets?.join(\",\"),\n      attributesToRetrieve: options?.attributesToRetrieve?.join(\",\"),\n      attributesToCrop: options?.attributesToCrop?.join(\",\"),\n      attributesToHighlight: options?.attributesToHighlight?.join(\",\"),\n      vector: options?.vector?.join(\",\"),\n      attributesToSearchOn: options?.attributesToSearchOn?.join(\",\"),\n    };\n\n    return await this.httpRequest.get<SearchResponse<D, S>>(\n      url,\n      removeUndefinedFromObject(getParams),\n      config,\n    );\n  }\n\n  /**\n   * Search for facet values\n   *\n   * @param params - Parameters used to search on the facets\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search response\n   */\n  async searchForFacetValues(\n    params: SearchForFacetValuesParams,\n    config?: Partial<Request>,\n  ): Promise<SearchForFacetValuesResponse> {\n    const url = `indexes/${this.uid}/facet-search`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject(params),\n      undefined,\n      config,\n    );\n  }\n\n  /**\n   * Search for similar documents\n   *\n   * @param params - Parameters used to search for similar documents\n   * @returns Promise containing the search response\n   */\n  async searchSimilarDocuments<\n    D extends Record<string, any> = T,\n    S extends SearchParams = SearchParams,\n  >(params: SearchSimilarDocumentsParams): Promise<SearchResponse<D, S>> {\n    const url = `indexes/${this.uid}/similar`;\n\n    return await this.httpRequest.post(\n      url,\n      removeUndefinedFromObject(params),\n      undefined,\n    );\n  }\n\n  ///\n  /// INDEX\n  ///\n\n  /**\n   * Get index information.\n   *\n   * @returns Promise containing index information\n   */\n  async getRawInfo(): Promise<IndexObject> {\n    const url = `indexes/${this.uid}`;\n    const res = await this.httpRequest.get<IndexObject>(url);\n    this.primaryKey = res.primaryKey;\n    this.updatedAt = new Date(res.updatedAt);\n    this.createdAt = new Date(res.createdAt);\n    return res;\n  }\n\n  /**\n   * Fetch and update Index information.\n   *\n   * @returns Promise to the current Index object with updated information\n   */\n  async fetchInfo(): Promise<this> {\n    await this.getRawInfo();\n    return this;\n  }\n\n  /**\n   * Get Primary Key.\n   *\n   * @returns Promise containing the Primary Key of the index\n   */\n  async fetchPrimaryKey(): Promise<string | undefined> {\n    this.primaryKey = (await this.getRawInfo()).primaryKey;\n    return this.primaryKey;\n  }\n\n  /**\n   * Create an index.\n   *\n   * @param uid - Unique identifier of the Index\n   * @param options - Index options\n   * @param config - Request configuration options\n   * @returns Newly created Index object\n   */\n  static async create(\n    uid: string,\n    options: IndexOptions = {},\n    config: Config,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes`;\n    const req = new HttpRequests(config);\n    const task = await req.post(url, { ...options, uid });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Update an index.\n   *\n   * @param data - Data to update\n   * @returns Promise to the current Index object with updated information\n   */\n  async update(data: IndexOptions): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}`;\n    const task = await this.httpRequest.patch(url, data);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Delete an index.\n   *\n   * @returns Promise which resolves when index is deleted successfully\n   */\n  async delete(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// TASKS\n  ///\n\n  /**\n   * Get the list of all the tasks of the index.\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise containing all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    return await this.tasks.getTasks({ ...parameters, indexUids: [this.uid] });\n  }\n\n  /**\n   * Get one task of the index.\n   *\n   * @param taskUid - Task identifier\n   * @returns Promise containing a task\n   */\n  async getTask(taskUid: number): Promise<Task> {\n    return await this.tasks.getTask(taskUid);\n  }\n\n  /**\n   * Wait for multiple tasks to be processed.\n   *\n   * @param taskUids - Tasks identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise containing an array of tasks\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    return await this.tasks.waitForTasks(taskUids, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Wait for a task to be processed.\n   *\n   * @param taskUid - Task identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise containing an array of tasks\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    return await this.tasks.waitForTask(taskUid, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  ///\n  /// STATS\n  ///\n\n  /**\n   * Get stats of an index\n   *\n   * @returns Promise containing object with stats of the index\n   */\n  async getStats(): Promise<IndexStats> {\n    const url = `indexes/${this.uid}/stats`;\n    return await this.httpRequest.get<IndexStats>(url);\n  }\n\n  ///\n  /// DOCUMENTS\n  ///\n\n  /**\n   * Get documents of an index.\n   *\n   * @param parameters - Parameters to browse the documents. Parameters can\n   *   contain the `filter` field only available in Meilisearch v1.2 and newer\n   * @returns Promise containing the returned documents\n   */\n  async getDocuments<D extends Record<string, any> = T>(\n    parameters: DocumentsQuery<D> = {},\n  ): Promise<ResourceResults<D[]>> {\n    parameters = removeUndefinedFromObject(parameters);\n\n    // In case `filter` is provided, use `POST /documents/fetch`\n    if (parameters.filter !== undefined) {\n      try {\n        const url = `indexes/${this.uid}/documents/fetch`;\n\n        return await this.httpRequest.post<\n          DocumentsQuery,\n          Promise<ResourceResults<D[]>>\n        >(url, parameters);\n      } catch (e) {\n        if (e instanceof MeiliSearchRequestError) {\n          e.message = versionErrorHintMessage(e.message, \"getDocuments\");\n        } else if (e instanceof MeiliSearchApiError) {\n          e.message = versionErrorHintMessage(e.message, \"getDocuments\");\n        }\n\n        throw e;\n      }\n      // Else use `GET /documents` method\n    } else {\n      const url = `indexes/${this.uid}/documents`;\n\n      // Transform fields to query parameter string format\n      const fields = Array.isArray(parameters?.fields)\n        ? { fields: parameters?.fields?.join(\",\") }\n        : {};\n\n      return await this.httpRequest.get<Promise<ResourceResults<D[]>>>(url, {\n        ...parameters,\n        ...fields,\n      });\n    }\n  }\n\n  /**\n   * Get one document\n   *\n   * @param documentId - Document ID\n   * @param parameters - Parameters applied on a document\n   * @returns Promise containing Document response\n   */\n  async getDocument<D extends Record<string, any> = T>(\n    documentId: string | number,\n    parameters?: DocumentQuery<T>,\n  ): Promise<D> {\n    const url = `indexes/${this.uid}/documents/${documentId}`;\n\n    const fields = (() => {\n      if (Array.isArray(parameters?.fields)) {\n        return parameters?.fields?.join(\",\");\n      }\n      return undefined;\n    })();\n\n    return await this.httpRequest.get<D>(\n      url,\n      removeUndefinedFromObject({\n        ...parameters,\n        fields,\n      }),\n    );\n  }\n\n  /**\n   * Add or replace multiples documents to an index\n   *\n   * @param documents - Array of Document objects to add/replace\n   * @param options - Options on document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async addDocuments(\n    documents: T[],\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.post(url, documents, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or replace multiples documents in a string format to an index. It only\n   * supports csv, ndjson and json formats.\n   *\n   * @param documents - Documents provided in a string to add/replace\n   * @param contentType - Content type of your document:\n   *   'text/csv'|'application/x-ndjson'|'application/json'\n   * @param options - Options on document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async addDocumentsFromString(\n    documents: string,\n    contentType: ContentType,\n    queryParams?: RawDocumentAdditionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n\n    const task = await this.httpRequest.post(url, documents, queryParams, {\n      headers: {\n        \"Content-Type\": contentType,\n      },\n    });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or replace multiples documents to an index in batches\n   *\n   * @param documents - Array of Document objects to add/replace\n   * @param batchSize - Size of the batch\n   * @param options - Options on document addition\n   * @returns Promise containing array of enqueued task objects for each batch\n   */\n  async addDocumentsInBatches(\n    documents: T[],\n    batchSize = 1000,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask[]> {\n    const updates = [];\n    for (let i = 0; i < documents.length; i += batchSize) {\n      updates.push(\n        await this.addDocuments(documents.slice(i, i + batchSize), options),\n      );\n    }\n    return updates;\n  }\n\n  /**\n   * Add or update multiples documents to an index\n   *\n   * @param documents - Array of Document objects to add/update\n   * @param options - Options on document update\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocuments(\n    documents: Array<Partial<T>>,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.put(url, documents, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Add or update multiples documents to an index in batches\n   *\n   * @param documents - Array of Document objects to add/update\n   * @param batchSize - Size of the batch\n   * @param options - Options on document update\n   * @returns Promise containing array of enqueued task objects for each batch\n   */\n  async updateDocumentsInBatches(\n    documents: Array<Partial<T>>,\n    batchSize = 1000,\n    options?: DocumentOptions,\n  ): Promise<EnqueuedTask[]> {\n    const updates = [];\n    for (let i = 0; i < documents.length; i += batchSize) {\n      updates.push(\n        await this.updateDocuments(documents.slice(i, i + batchSize), options),\n      );\n    }\n    return updates;\n  }\n\n  /**\n   * Add or update multiples documents in a string format to an index. It only\n   * supports csv, ndjson and json formats.\n   *\n   * @param documents - Documents provided in a string to add/update\n   * @param contentType - Content type of your document:\n   *   'text/csv'|'application/x-ndjson'|'application/json'\n   * @param queryParams - Options on raw document addition\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocumentsFromString(\n    documents: string,\n    contentType: ContentType,\n    queryParams?: RawDocumentAdditionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n\n    const task = await this.httpRequest.put(url, documents, queryParams, {\n      headers: {\n        \"Content-Type\": contentType,\n      },\n    });\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Delete one document\n   *\n   * @param documentId - Id of Document to delete\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteDocument(documentId: string | number): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents/${documentId}`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Delete multiples documents of an index.\n   *\n   * @param params - Params value can be:\n   *\n   *   - DocumentsDeletionQuery: An object containing the parameters to customize\n   *       your document deletion. Only available in Meilisearch v1.2 and newer\n   *   - DocumentsIds: An array of document ids to delete\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteDocuments(\n    params: DocumentsDeletionQuery | DocumentsIds,\n  ): Promise<EnqueuedTask> {\n    // If params is of type DocumentsDeletionQuery\n    const isDocumentsDeletionQuery =\n      !Array.isArray(params) && typeof params === \"object\";\n    const endpoint = isDocumentsDeletionQuery\n      ? \"documents/delete\"\n      : \"documents/delete-batch\";\n    const url = `indexes/${this.uid}/${endpoint}`;\n\n    try {\n      const task = await this.httpRequest.post(url, params);\n\n      return new EnqueuedTask(task);\n    } catch (e) {\n      if (e instanceof MeiliSearchRequestError && isDocumentsDeletionQuery) {\n        e.message = versionErrorHintMessage(e.message, \"deleteDocuments\");\n      } else if (e instanceof MeiliSearchApiError) {\n        e.message = versionErrorHintMessage(e.message, \"deleteDocuments\");\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Delete all documents of an index\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteAllDocuments(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * This is an EXPERIMENTAL feature, which may break without a major version.\n   * It's available after Meilisearch v1.10.\n   *\n   * More info about the feature:\n   * https://github.com/orgs/meilisearch/discussions/762 More info about\n   * experimental features in general:\n   * https://www.meilisearch.com/docs/reference/api/experimental-features\n   *\n   * @param options - Object containing the function string and related options\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDocumentsByFunction(\n    options: UpdateDocumentsByFunctionOptions,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/documents/edit`;\n    const task = await this.httpRequest.post(url, options);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SETTINGS\n  ///\n\n  /**\n   * Retrieve all settings\n   *\n   * @returns Promise containing Settings object\n   */\n  async getSettings(): Promise<Settings> {\n    const url = `indexes/${this.uid}/settings`;\n    return await this.httpRequest.get<Settings>(url);\n  }\n\n  /**\n   * Update all settings Any parameters not provided will be left unchanged.\n   *\n   * @param settings - Object containing parameters with their updated values\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSettings(settings: Settings): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings`;\n    const task = await this.httpRequest.patch(url, settings);\n\n    task.enqueued = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Reset settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSettings(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// PAGINATION SETTINGS\n  ///\n\n  /**\n   * Get the pagination settings.\n   *\n   * @returns Promise containing object of pagination settings\n   */\n  async getPagination(): Promise<PaginationSettings> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    return await this.httpRequest.get<object>(url);\n  }\n\n  /**\n   * Update the pagination settings.\n   *\n   * @param pagination - Pagination object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updatePagination(\n    pagination: PaginationSettings,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    const task = await this.httpRequest.patch(url, pagination);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the pagination settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetPagination(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/pagination`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SYNONYMS\n  ///\n\n  /**\n   * Get the list of all synonyms\n   *\n   * @returns Promise containing object of synonym mappings\n   */\n  async getSynonyms(): Promise<object> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    return await this.httpRequest.get<object>(url);\n  }\n\n  /**\n   * Update the list of synonyms. Overwrite the old list.\n   *\n   * @param synonyms - Mapping of synonyms with their associated words\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSynonyms(synonyms: Synonyms): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    const task = await this.httpRequest.put(url, synonyms);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the synonym list to be empty again\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSynonyms(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/synonyms`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// STOP WORDS\n  ///\n\n  /**\n   * Get the list of all stop-words\n   *\n   * @returns Promise containing array of stop-words\n   */\n  async getStopWords(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of stop-words. Overwrite the old list.\n   *\n   * @param stopWords - Array of strings that contains the stop-words.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateStopWords(stopWords: StopWords): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    const task = await this.httpRequest.put(url, stopWords);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the stop-words list to be empty again\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetStopWords(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/stop-words`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// RANKING RULES\n  ///\n\n  /**\n   * Get the list of all ranking-rules\n   *\n   * @returns Promise containing array of ranking-rules\n   */\n  async getRankingRules(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of ranking-rules. Overwrite the old list.\n   *\n   * @param rankingRules - Array that contain ranking rules sorted by order of\n   *   importance.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateRankingRules(rankingRules: RankingRules): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    const task = await this.httpRequest.put(url, rankingRules);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the ranking rules list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetRankingRules(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/ranking-rules`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DISTINCT ATTRIBUTE\n  ///\n\n  /**\n   * Get the distinct-attribute\n   *\n   * @returns Promise containing the distinct-attribute of the index\n   */\n  async getDistinctAttribute(): Promise<string | null> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    return await this.httpRequest.get<string | null>(url);\n  }\n\n  /**\n   * Update the distinct-attribute.\n   *\n   * @param distinctAttribute - Field name of the distinct-attribute\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDistinctAttribute(\n    distinctAttribute: DistinctAttribute,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    const task = await this.httpRequest.put(url, distinctAttribute);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the distinct-attribute.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDistinctAttribute(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/distinct-attribute`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// FILTERABLE ATTRIBUTES\n  ///\n\n  /**\n   * Get the filterable-attributes\n   *\n   * @returns Promise containing an array of filterable-attributes\n   */\n  async getFilterableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the filterable-attributes.\n   *\n   * @param filterableAttributes - Array of strings containing the attributes\n   *   that can be used as filters at query time\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFilterableAttributes(\n    filterableAttributes: FilterableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    const task = await this.httpRequest.put(url, filterableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the filterable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFilterableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/filterable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SORTABLE ATTRIBUTES\n  ///\n\n  /**\n   * Get the sortable-attributes\n   *\n   * @returns Promise containing array of sortable-attributes\n   */\n  async getSortableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the sortable-attributes.\n   *\n   * @param sortableAttributes - Array of strings containing the attributes that\n   *   can be used to sort search results at query time\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSortableAttributes(\n    sortableAttributes: SortableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    const task = await this.httpRequest.put(url, sortableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the sortable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSortableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/sortable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SEARCHABLE ATTRIBUTE\n  ///\n\n  /**\n   * Get the searchable-attributes\n   *\n   * @returns Promise containing array of searchable-attributes\n   */\n  async getSearchableAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the searchable-attributes.\n   *\n   * @param searchableAttributes - Array of strings that contains searchable\n   *   attributes sorted by order of importance(most to least important)\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSearchableAttributes(\n    searchableAttributes: SearchableAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    const task = await this.httpRequest.put(url, searchableAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the searchable-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSearchableAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/searchable-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DISPLAYED ATTRIBUTE\n  ///\n\n  /**\n   * Get the displayed-attributes\n   *\n   * @returns Promise containing array of displayed-attributes\n   */\n  async getDisplayedAttributes(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the displayed-attributes.\n   *\n   * @param displayedAttributes - Array of strings that contains attributes of\n   *   an index to display\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateDisplayedAttributes(\n    displayedAttributes: DisplayedAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    const task = await this.httpRequest.put(url, displayedAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the displayed-attributes.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDisplayedAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/displayed-attributes`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// TYPO TOLERANCE\n  ///\n\n  /**\n   * Get the typo tolerance settings.\n   *\n   * @returns Promise containing the typo tolerance settings.\n   */\n  async getTypoTolerance(): Promise<TypoTolerance> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    return await this.httpRequest.get<TypoTolerance>(url);\n  }\n\n  /**\n   * Update the typo tolerance settings.\n   *\n   * @param typoTolerance - Object containing the custom typo tolerance\n   *   settings.\n   * @returns Promise containing object of the enqueued update\n   */\n  async updateTypoTolerance(\n    typoTolerance: TypoTolerance,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    const task = await this.httpRequest.patch(url, typoTolerance);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  /**\n   * Reset the typo tolerance settings.\n   *\n   * @returns Promise containing object of the enqueued update\n   */\n  async resetTypoTolerance(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/typo-tolerance`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// FACETING\n  ///\n\n  /**\n   * Get the faceting settings.\n   *\n   * @returns Promise containing object of faceting index settings\n   */\n  async getFaceting(): Promise<Faceting> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    return await this.httpRequest.get<Faceting>(url);\n  }\n\n  /**\n   * Update the faceting settings.\n   *\n   * @param faceting - Faceting index settings object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFaceting(faceting: Faceting): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    const task = await this.httpRequest.patch(url, faceting);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the faceting settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFaceting(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/faceting`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SEPARATOR TOKENS\n  ///\n\n  /**\n   * Get the list of all separator tokens.\n   *\n   * @returns Promise containing array of separator tokens\n   */\n  async getSeparatorTokens(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of separator tokens. Overwrite the old list.\n   *\n   * @param separatorTokens - Array that contains separator tokens.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateSeparatorTokens(\n    separatorTokens: SeparatorTokens,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    const task = await this.httpRequest.put(url, separatorTokens);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the separator tokens list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSeparatorTokens(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/separator-tokens`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// NON-SEPARATOR TOKENS\n  ///\n\n  /**\n   * Get the list of all non-separator tokens.\n   *\n   * @returns Promise containing array of non-separator tokens\n   */\n  async getNonSeparatorTokens(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the list of non-separator tokens. Overwrite the old list.\n   *\n   * @param nonSeparatorTokens - Array that contains non-separator tokens.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateNonSeparatorTokens(\n    nonSeparatorTokens: NonSeparatorTokens,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    const task = await this.httpRequest.put(url, nonSeparatorTokens);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the non-separator tokens list to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetNonSeparatorTokens(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/non-separator-tokens`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// DICTIONARY\n  ///\n\n  /**\n   * Get the dictionary settings of a Meilisearch index.\n   *\n   * @returns Promise containing the dictionary settings\n   */\n  async getDictionary(): Promise<string[]> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    return await this.httpRequest.get<string[]>(url);\n  }\n\n  /**\n   * Update the dictionary settings. Overwrite the old settings.\n   *\n   * @param dictionary - Array that contains the new dictionary settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateDictionary(dictionary: Dictionary): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    const task = await this.httpRequest.put(url, dictionary);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the dictionary settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetDictionary(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/dictionary`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// PROXIMITY PRECISION\n  ///\n\n  /**\n   * Get the proximity precision settings of a Meilisearch index.\n   *\n   * @returns Promise containing the proximity precision settings\n   */\n  async getProximityPrecision(): Promise<ProximityPrecision> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    return await this.httpRequest.get<ProximityPrecision>(url);\n  }\n\n  /**\n   * Update the proximity precision settings. Overwrite the old settings.\n   *\n   * @param proximityPrecision - String that contains the new proximity\n   *   precision settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateProximityPrecision(\n    proximityPrecision: ProximityPrecision,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    const task = await this.httpRequest.put(url, proximityPrecision);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the proximity precision settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetProximityPrecision(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/proximity-precision`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// EMBEDDERS\n  ///\n\n  /**\n   * Get the embedders settings of a Meilisearch index.\n   *\n   * @returns Promise containing the embedders settings\n   */\n  async getEmbedders(): Promise<Embedders> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    return await this.httpRequest.get<Embedders>(url);\n  }\n\n  /**\n   * Update the embedders settings. Overwrite the old settings.\n   *\n   * @param embedders - Object that contains the new embedders settings.\n   * @returns Promise containing an EnqueuedTask or null\n   */\n  async updateEmbedders(embedders: Embedders): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    const task = await this.httpRequest.patch(url, embedders);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the embedders settings to its default value\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetEmbedders(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/embedders`;\n    const task = await this.httpRequest.delete<EnqueuedTask>(url);\n\n    task.enqueuedAt = new Date(task.enqueuedAt);\n\n    return task;\n  }\n\n  ///\n  /// SEARCHCUTOFFMS SETTINGS\n  ///\n\n  /**\n   * Get the SearchCutoffMs settings.\n   *\n   * @returns Promise containing object of SearchCutoffMs settings\n   */\n  async getSearchCutoffMs(): Promise<SearchCutoffMs> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    return await this.httpRequest.get<SearchCutoffMs>(url);\n  }\n\n  /**\n   * Update the SearchCutoffMs settings.\n   *\n   * @param searchCutoffMs - Object containing SearchCutoffMsSettings\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateSearchCutoffMs(\n    searchCutoffMs: SearchCutoffMs,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    const task = await this.httpRequest.put(url, searchCutoffMs);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the SearchCutoffMs settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetSearchCutoffMs(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// LOCALIZED ATTRIBUTES SETTINGS\n  ///\n\n  /**\n   * Get the localized attributes settings.\n   *\n   * @returns Promise containing object of localized attributes settings\n   */\n  async getLocalizedAttributes(): Promise<LocalizedAttributes> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    return await this.httpRequest.get<LocalizedAttributes>(url);\n  }\n\n  /**\n   * Update the localized attributes settings.\n   *\n   * @param localizedAttributes - Localized attributes object\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateLocalizedAttributes(\n    localizedAttributes: LocalizedAttributes,\n  ): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    const task = await this.httpRequest.put(url, localizedAttributes);\n\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the localized attributes settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetLocalizedAttributes(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/localized-attributes`;\n    const task = await this.httpRequest.delete(url);\n\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// FACET SEARCH SETTINGS\n  ///\n\n  /**\n   * Get the facet search settings.\n   *\n   * @returns Promise containing object of facet search settings\n   */\n  async getFacetSearch(): Promise<boolean> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    return await this.httpRequest.get<boolean>(url);\n  }\n\n  /**\n   * Update the facet search settings.\n   *\n   * @param facetSearch - Boolean value\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updateFacetSearch(facetSearch: boolean): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    const task = await this.httpRequest.put(url, facetSearch);\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the facet search settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetFacetSearch(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/facet-search`;\n    const task = await this.httpRequest.delete(url);\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// PREFIX SEARCH SETTINGS\n  ///\n\n  /**\n   * Get the prefix search settings.\n   *\n   * @returns Promise containing object of prefix search settings\n   */\n  async getPrefixSearch(): Promise<PrefixSearch> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    return await this.httpRequest.get<PrefixSearch>(url);\n  }\n\n  /**\n   * Update the prefix search settings.\n   *\n   * @param prefixSearch - PrefixSearch value\n   * @returns Promise containing an EnqueuedTask\n   */\n  async updatePrefixSearch(prefixSearch: PrefixSearch): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    const task = await this.httpRequest.put(url, prefixSearch);\n    return new EnqueuedTask(task);\n  }\n\n  /**\n   * Reset the prefix search settings.\n   *\n   * @returns Promise containing an EnqueuedTask\n   */\n  async resetPrefixSearch(): Promise<EnqueuedTask> {\n    const url = `indexes/${this.uid}/settings/prefix-search`;\n    const task = await this.httpRequest.delete(url);\n    return new EnqueuedTask(task);\n  }\n}\n\nexport { Index };\n","/*\n * Bundle: MeiliSearch\n * Project: MeiliSearch - Javascript API\n * Author: Quentin de Quelen <quentin@meilisearch.com>\n * Copyright: 2019, MeiliSearch\n */\n\nimport { Index } from \"./indexes.js\";\nimport type {\n  KeyCreation,\n  Config,\n  IndexOptions,\n  IndexObject,\n  Key,\n  Health,\n  Stats,\n  Version,\n  TasksQuery,\n  WaitOptions,\n  KeyUpdate,\n  IndexesQuery,\n  IndexesResults,\n  KeysQuery,\n  KeysResults,\n  TasksResults,\n  EnqueuedTaskObject,\n  SwapIndexesParams,\n  CancelTasksQuery,\n  DeleteTasksQuery,\n  MultiSearchParams,\n  FederatedMultiSearchParams,\n  BatchesResults,\n  BatchesQuery,\n  MultiSearchResponseOrSearchResponse,\n} from \"./types.js\";\nimport { ErrorStatusCode } from \"./types.js\";\nimport { HttpRequests } from \"./http-requests.js\";\nimport { TaskClient, type Task } from \"./task.js\";\nimport { EnqueuedTask } from \"./enqueued-task.js\";\nimport { type Batch, BatchClient } from \"./batch.js\";\n\nexport class MeiliSearch {\n  config: Config;\n  httpRequest: HttpRequests;\n  tasks: TaskClient;\n  batches: BatchClient;\n\n  /**\n   * Creates new MeiliSearch instance\n   *\n   * @param config - Configuration object\n   */\n  constructor(config: Config) {\n    this.config = config;\n    this.httpRequest = new HttpRequests(config);\n    this.tasks = new TaskClient(config);\n    this.batches = new BatchClient(config);\n  }\n\n  /**\n   * Return an Index instance\n   *\n   * @param indexUid - The index UID\n   * @returns Instance of Index\n   */\n  index<T extends Record<string, any> = Record<string, any>>(\n    indexUid: string,\n  ): Index<T> {\n    return new Index<T>(this.config, indexUid);\n  }\n\n  /**\n   * Gather information about an index by calling MeiliSearch and return an\n   * Index instance with the gathered information\n   *\n   * @param indexUid - The index UID\n   * @returns Promise returning Index instance\n   */\n  async getIndex<T extends Record<string, any> = Record<string, any>>(\n    indexUid: string,\n  ): Promise<Index<T>> {\n    return new Index<T>(this.config, indexUid).fetchInfo();\n  }\n\n  /**\n   * Gather information about an index by calling MeiliSearch and return the raw\n   * JSON response\n   *\n   * @param indexUid - The index UID\n   * @returns Promise returning index information\n   */\n  async getRawIndex(indexUid: string): Promise<IndexObject> {\n    return new Index(this.config, indexUid).getRawInfo();\n  }\n\n  /**\n   * Get all the indexes as Index instances.\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning array of raw index information\n   */\n  async getIndexes(\n    parameters: IndexesQuery = {},\n  ): Promise<IndexesResults<Index[]>> {\n    const rawIndexes = await this.getRawIndexes(parameters);\n    const indexes: Index[] = rawIndexes.results.map(\n      (index) => new Index(this.config, index.uid, index.primaryKey),\n    );\n    return { ...rawIndexes, results: indexes };\n  }\n\n  /**\n   * Get all the indexes in their raw value (no Index instances).\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning array of raw index information\n   */\n  async getRawIndexes(\n    parameters: IndexesQuery = {},\n  ): Promise<IndexesResults<IndexObject[]>> {\n    const url = `indexes`;\n    return await this.httpRequest.get<IndexesResults<IndexObject[]>>(\n      url,\n      parameters,\n    );\n  }\n\n  /**\n   * Create a new index\n   *\n   * @param uid - The index UID\n   * @param options - Index options\n   * @returns Promise returning Index instance\n   */\n  async createIndex(\n    uid: string,\n    options: IndexOptions = {},\n  ): Promise<EnqueuedTask> {\n    return await Index.create(uid, options, this.config);\n  }\n\n  /**\n   * Update an index\n   *\n   * @param uid - The index UID\n   * @param options - Index options to update\n   * @returns Promise returning Index instance after updating\n   */\n  async updateIndex(\n    uid: string,\n    options: IndexOptions = {},\n  ): Promise<EnqueuedTask> {\n    return await new Index(this.config, uid).update(options);\n  }\n\n  /**\n   * Delete an index\n   *\n   * @param uid - The index UID\n   * @returns Promise which resolves when index is deleted successfully\n   */\n  async deleteIndex(uid: string): Promise<EnqueuedTask> {\n    return await new Index(this.config, uid).delete();\n  }\n\n  /**\n   * Deletes an index if it already exists.\n   *\n   * @param uid - The index UID\n   * @returns Promise which resolves to true when index exists and is deleted\n   *   successfully, otherwise false if it does not exist\n   */\n  async deleteIndexIfExists(uid: string): Promise<boolean> {\n    try {\n      await this.deleteIndex(uid);\n      return true;\n    } catch (e: any) {\n      if (e.code === ErrorStatusCode.INDEX_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Swaps a list of index tuples.\n   *\n   * @param params - List of indexes tuples to swap.\n   * @returns Promise returning object of the enqueued task\n   */\n  async swapIndexes(params: SwapIndexesParams): Promise<EnqueuedTask> {\n    const url = \"/swap-indexes\";\n    return await this.httpRequest.post(url, params);\n  }\n\n  ///\n  /// Multi Search\n  ///\n\n  /**\n   * Perform multiple search queries.\n   *\n   * It is possible to make multiple search queries on the same index or on\n   * different ones\n   *\n   * @example\n   *\n   * ```ts\n   * client.multiSearch({\n   *   queries: [\n   *     { indexUid: \"movies\", q: \"wonder\" },\n   *     { indexUid: \"books\", q: \"flower\" },\n   *   ],\n   * });\n   * ```\n   *\n   * @param queries - Search queries\n   * @param config - Additional request configuration options\n   * @returns Promise containing the search responses\n   */\n  async multiSearch<\n    T1 extends MultiSearchParams | FederatedMultiSearchParams,\n    T2 extends Record<string, unknown> = Record<string, any>,\n  >(\n    queries: T1,\n    config?: Partial<Request>,\n  ): Promise<MultiSearchResponseOrSearchResponse<T1, T2>> {\n    const url = `multi-search`;\n\n    return await this.httpRequest.post(url, queries, undefined, config);\n  }\n\n  ///\n  /// TASKS\n  ///\n\n  /**\n   * Get the list of all client tasks\n   *\n   * @param parameters - Parameters to browse the tasks\n   * @returns Promise returning all tasks\n   */\n  async getTasks(parameters: TasksQuery = {}): Promise<TasksResults> {\n    return await this.tasks.getTasks(parameters);\n  }\n\n  /**\n   * Get one task on the client scope\n   *\n   * @param taskUid - Task identifier\n   * @returns Promise returning a task\n   */\n  async getTask(taskUid: number): Promise<Task> {\n    return await this.tasks.getTask(taskUid);\n  }\n\n  /**\n   * Wait for multiple tasks to be finished.\n   *\n   * @param taskUids - Tasks identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise returning an array of tasks\n   */\n  async waitForTasks(\n    taskUids: number[],\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task[]> {\n    return await this.tasks.waitForTasks(taskUids, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Wait for a task to be finished.\n   *\n   * @param taskUid - Task identifier\n   * @param waitOptions - Options on timeout and interval\n   * @returns Promise returning an array of tasks\n   */\n  async waitForTask(\n    taskUid: number,\n    { timeOutMs = 5000, intervalMs = 50 }: WaitOptions = {},\n  ): Promise<Task> {\n    return await this.tasks.waitForTask(taskUid, {\n      timeOutMs,\n      intervalMs,\n    });\n  }\n\n  /**\n   * Cancel a list of enqueued or processing tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async cancelTasks(parameters: CancelTasksQuery): Promise<EnqueuedTask> {\n    return await this.tasks.cancelTasks(parameters);\n  }\n\n  /**\n   * Delete a list of tasks.\n   *\n   * @param parameters - Parameters to filter the tasks.\n   * @returns Promise containing an EnqueuedTask\n   */\n  async deleteTasks(parameters: DeleteTasksQuery = {}): Promise<EnqueuedTask> {\n    return await this.tasks.deleteTasks(parameters);\n  }\n\n  /**\n   * Get all the batches\n   *\n   * @param parameters - Parameters to browse the batches\n   * @returns Promise returning all batches\n   */\n  async getBatches(parameters: BatchesQuery = {}): Promise<BatchesResults> {\n    return await this.batches.getBatches(parameters);\n  }\n\n  /**\n   * Get one batch\n   *\n   * @param uid - Batch identifier\n   * @returns Promise returning a batch\n   */\n  async getBatch(uid: number): Promise<Batch> {\n    return await this.batches.getBatch(uid);\n  }\n\n  ///\n  /// KEYS\n  ///\n\n  /**\n   * Get all API keys\n   *\n   * @param parameters - Parameters to browse the indexes\n   * @returns Promise returning an object with keys\n   */\n  async getKeys(parameters: KeysQuery = {}): Promise<KeysResults> {\n    const url = `keys`;\n    const keys = await this.httpRequest.get<KeysResults>(url, parameters);\n\n    keys.results = keys.results.map((key) => ({\n      ...key,\n      createdAt: new Date(key.createdAt),\n      updatedAt: new Date(key.updatedAt),\n    }));\n\n    return keys;\n  }\n\n  /**\n   * Get one API key\n   *\n   * @param keyOrUid - Key or uid of the API key\n   * @returns Promise returning a key\n   */\n  async getKey(keyOrUid: string): Promise<Key> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.get<Key>(url);\n  }\n\n  /**\n   * Create one API key\n   *\n   * @param options - Key options\n   * @returns Promise returning a key\n   */\n  async createKey(options: KeyCreation): Promise<Key> {\n    const url = `keys`;\n    return await this.httpRequest.post(url, options);\n  }\n\n  /**\n   * Update one API key\n   *\n   * @param keyOrUid - Key\n   * @param options - Key options\n   * @returns Promise returning a key\n   */\n  async updateKey(keyOrUid: string, options: KeyUpdate): Promise<Key> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.patch(url, options);\n  }\n\n  /**\n   * Delete one API key\n   *\n   * @param keyOrUid - Key\n   * @returns\n   */\n  async deleteKey(keyOrUid: string): Promise<void> {\n    const url = `keys/${keyOrUid}`;\n    return await this.httpRequest.delete<any>(url);\n  }\n\n  ///\n  /// HEALTH\n  ///\n\n  /**\n   * Checks if the server is healthy, otherwise an error will be thrown.\n   *\n   * @returns Promise returning an object with health details\n   */\n  async health(): Promise<Health> {\n    const url = `health`;\n    return await this.httpRequest.get<Health>(url);\n  }\n\n  /**\n   * Checks if the server is healthy, return true or false.\n   *\n   * @returns Promise returning a boolean\n   */\n  async isHealthy(): Promise<boolean> {\n    try {\n      const url = `health`;\n      await this.httpRequest.get(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  ///\n  /// STATS\n  ///\n\n  /**\n   * Get the stats of all the database\n   *\n   * @returns Promise returning object of all the stats\n   */\n  async getStats(): Promise<Stats> {\n    const url = `stats`;\n    return await this.httpRequest.get<Stats>(url);\n  }\n\n  ///\n  /// VERSION\n  ///\n\n  /**\n   * Get the version of MeiliSearch\n   *\n   * @returns Promise returning object with version details\n   */\n  async getVersion(): Promise<Version> {\n    const url = `version`;\n    return await this.httpRequest.get<Version>(url);\n  }\n\n  ///\n  /// DUMPS\n  ///\n\n  /**\n   * Creates a dump\n   *\n   * @returns Promise returning object of the enqueued task\n   */\n  async createDump(): Promise<EnqueuedTask> {\n    const url = `dumps`;\n    const task = await this.httpRequest.post<undefined, EnqueuedTaskObject>(\n      url,\n    );\n    return new EnqueuedTask(task);\n  }\n\n  ///\n  /// SNAPSHOTS\n  ///\n\n  /**\n   * Creates a snapshot\n   *\n   * @returns Promise returning object of the enqueued task\n   */\n  async createSnapshot(): Promise<EnqueuedTask> {\n    const url = `snapshots`;\n    const task = await this.httpRequest.post<undefined, EnqueuedTaskObject>(\n      url,\n    );\n\n    return new EnqueuedTask(task);\n  }\n}\n","export * from \"./types.js\";\nexport * from \"./errors/index.js\";\nexport * from \"./indexes.js\";\nexport * from \"./enqueued-task.js\";\nexport * from \"./task.js\";\nimport { MeiliSearch } from \"./meilisearch.js\";\n\n/**\n * Default export of {@link MeiliSearch}.\n *\n * @deprecated The default export will be removed in a future version.\n *   {@link https://github.com/meilisearch/meilisearch-js/issues/1789 | Issue}.\n */\nconst defaultExport = MeiliSearch;\n\nexport { MeiliSearch, MeiliSearch as Meilisearch };\nexport default defaultExport;\n"],"names":["MeiliSearchError","params","__publicField","MeiliSearchApiError","response","responseBody","_a","MeiliSearchRequestError","url","cause","MeiliSearchTimeOutError","message","versionErrorHintMessage","method","PACKAGE_VERSION","removeUndefinedFromObject","obj","acc","curEntry","key","val","sleep","ms","__async","resolve","addProtocolIfNotPresent","host","addTrailingSlash","toQueryParams","parameters","value","__spreadProps","__spreadValues","constructHostURL","e","cloneAndParseHeaders","headers","headerPair","clonedHeaders","createHeaders","config","agentHeader","packageAgent","contentType","authorization","_b","clients","HttpRequests","_0","body","constructURL","queryParams","x","error","parsedResponse","options","timeout","reject","promises","timeoutId","timeoutPromise","_","data","EnqueuedTask","task","Task","TaskClient","uid","taskItem","tasks","taskUid","timeOutMs","intervalMs","startingTime","TaskStatus","taskUids","Batch","batch","BatchClient","batches","MatchingStrategies","ContentTypeEnum","TaskTypes","ErrorStatusCode","Index","primaryKey","query","parseFilter","filter","getParams","_c","_d","_e","_f","_g","res","fields","documentId","documents","batchSize","updates","i","isDocumentsDeletionQuery","endpoint","settings","pagination","synonyms","stopWords","rankingRules","distinctAttribute","filterableAttributes","sortableAttributes","searchableAttributes","displayedAttributes","typoTolerance","faceting","separatorTokens","nonSeparatorTokens","dictionary","proximityPrecision","embedders","searchCutoffMs","localizedAttributes","facetSearch","prefixSearch","MeiliSearch","indexUid","rawIndexes","indexes","index","queries","keys","keyOrUid","defaultExport"],"mappings":"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"}