"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dbTestUtilFactory = void 0;
exports.getDatabaseURL = getDatabaseURL;
exports.getMikroOrmConfig = getMikroOrmConfig;
exports.getMikroOrmWrapper = getMikroOrmWrapper;
const postgresql_1 = require("@mikro-orm/postgresql");
const pg_god_1 = require("pg-god");
const DB_HOST = process.env.DB_HOST ?? "localhost";
const DB_USERNAME = process.env.DB_USERNAME ?? "";
const DB_PASSWORD = process.env.DB_PASSWORD ?? "";
const pgGodCredentials = {
    user: DB_USERNAME,
    password: DB_PASSWORD,
    host: DB_HOST,
};
function getDatabaseURL(dbName) {
    const DB_HOST = process.env.DB_HOST ?? "localhost";
    const DB_USERNAME = process.env.DB_USERNAME ?? "postgres";
    const DB_PASSWORD = process.env.DB_PASSWORD ?? "";
    const DB_NAME = dbName ?? process.env.DB_TEMP_NAME;
    return `postgres://${DB_USERNAME}${DB_PASSWORD ? `:${DB_PASSWORD}` : ""}@${DB_HOST}/${DB_NAME}`;
}
function getMikroOrmConfig({ mikroOrmEntities, pathToMigrations, clientUrl, schema, }) {
    const DB_URL = clientUrl ?? getDatabaseURL();
    return (0, postgresql_1.defineConfig)({
        clientUrl: DB_URL,
        entities: Object.values(mikroOrmEntities),
        schema: schema ?? process.env.MEDUSA_DB_SCHEMA,
        debug: false,
        pool: {
            min: 2,
        },
        migrations: {
            pathTs: pathToMigrations,
            silent: true,
        },
    });
}
function getMikroOrmWrapper({ mikroOrmEntities, pathToMigrations, clientUrl, schema, }) {
    return {
        mikroOrmEntities,
        pathToMigrations,
        clientUrl: clientUrl ?? getDatabaseURL(),
        schema: schema ?? process.env.MEDUSA_DB_SCHEMA,
        orm: null,
        manager: null,
        getManager() {
            if (this.manager === null) {
                throw new Error("manager entity not available");
            }
            return this.manager;
        },
        forkManager() {
            if (this.manager === null) {
                throw new Error("manager entity not available");
            }
            return this.manager.fork();
        },
        getOrm() {
            if (this.orm === null) {
                throw new Error("orm entity not available");
            }
            return this.orm;
        },
        async setupDatabase() {
            const OrmConfig = getMikroOrmConfig({
                mikroOrmEntities: this.mikroOrmEntities,
                pathToMigrations: this.pathToMigrations,
                clientUrl: this.clientUrl,
                schema: this.schema,
            });
            // Initializing the ORM
            this.orm = await postgresql_1.MikroORM.init(OrmConfig);
            this.manager = this.orm.em;
            try {
                await this.orm.getSchemaGenerator().ensureDatabase();
            }
            catch (err) {
                console.log(err);
            }
            await this.manager?.execute(`CREATE SCHEMA IF NOT EXISTS "${this.schema ?? "public"}";`);
            const pendingMigrations = await this.orm
                .getMigrator()
                .getPendingMigrations();
            if (pendingMigrations && pendingMigrations.length > 0) {
                await this.orm
                    .getMigrator()
                    .up({ migrations: pendingMigrations.map((m) => m.name) });
            }
            else {
                await this.orm.schema.refreshDatabase(); // ensure db exists and is fresh
            }
        },
        async clearDatabase() {
            if (this.orm === null) {
                throw new Error("ORM not configured");
            }
            await this.manager?.execute(`DROP SCHEMA IF EXISTS "${this.schema ?? "public"}" CASCADE;`);
            await this.manager?.execute(`CREATE SCHEMA IF NOT EXISTS "${this.schema ?? "public"}";`);
            try {
                await this.orm.close();
            }
            catch { }
            this.orm = null;
            this.manager = null;
        },
    };
}
const dbTestUtilFactory = () => ({
    pgConnection_: null,
    create: async function (dbName) {
        await (0, pg_god_1.createDatabase)({ databaseName: dbName, errorIfExist: false }, pgGodCredentials);
    },
    teardown: async function ({ schema } = {}) {
        if (!this.pgConnection_) {
            return;
        }
        const runRawQuery = this.pgConnection_.raw.bind(this.pgConnection_);
        schema ??= "public";
        await runRawQuery(`SET session_replication_role = 'replica';`);
        const { rows: tableNames } = await runRawQuery(`SELECT table_name
                                            FROM information_schema.tables
                                            WHERE table_schema = '${schema}';`);
        for (const { table_name } of tableNames) {
            await runRawQuery(`DELETE
                           FROM ${schema}."${table_name}";`);
        }
        await runRawQuery(`SET session_replication_role = 'origin';`);
    },
    shutdown: async function (dbName) {
        await this.pgConnection_?.context?.destroy();
        await this.pgConnection_?.destroy();
        return await (0, pg_god_1.dropDatabase)({ databaseName: dbName, errorIfNonExist: false }, pgGodCredentials);
    },
});
exports.dbTestUtilFactory = dbTestUtilFactory;
//# sourceMappingURL=database.js.map